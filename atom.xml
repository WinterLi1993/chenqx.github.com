<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ShinChan's Blog]]></title>
  <subtitle><![CDATA[Vi Veri Veniversum Vivus Vici]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://chenqx.github.com/"/>
  <updated>2014-11-29T13:22:22.552Z</updated>
  <id>http://chenqx.github.com/</id>
  
  <author>
    <name><![CDATA[ShinChan]]></name>
    <email><![CDATA[chenqiuxing@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Python 2.7.x 与 Python 3.x 的主要差异]]></title>
    <link href="http://chenqx.github.com/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/"/>
    <id>http://chenqx.github.com/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/</id>
    <published>2014-11-10T12:04:25.000Z</published>
    <updated>2014-11-11T02:02:01.000Z</updated>
    <content type="html"><![CDATA[<p>　　因这学期负责Python课程的助教，刚开始上机试验的几节课，有很多同学用 Python3.4 的编译器编译 Python 2.7 的程序而导致不通过。Python 2.7.x 和 Python 3.x 版本并非完全兼容。<br>　　许多 Python 初学者想知道他们应该从 Python 的哪个版本开始学习。对于这个问题我的答案是 “你学习你喜欢的教程的版本，然后检查他们之间的不同。” 但如果你并未了解过两个版本之间的差异，个人推荐使用 Python 2.7.x 版本，毕竟大部分教材等资料还是用Python 2.7.x来写的。<br>　　但是如果你开始一个新项目，并且有选择权？我想说的是目前没有对错，只要你计划使用的库 Python 2.7.x 和 Python 3.x 双方都支持的话。尽管如此，当在编写它们中的任何一个的代码，或者是你计划移植你的项目的时候，是非常值得看看这两个主要流行的 Python 版本之间的差别的，以便避免常见的陷阱。<br>　　本文翻译自：<a href="http://nbviewer.ipython.org/github/rasbt/python_reference/blob/master/tutorials/key_differences_between_python_2_and_3.ipynb?create=1" target="_blank" rel="external">《Key differences between Python 2.7.x and Python 3.x》</a></p>
<h2 id="__future__模块"><strong><code>__future__</code>模块</strong></h2>
<p>　　Python 3.x 介绍的 一些Python 2 不兼容的关键字和特性可以通过在 Python 2 的内置 <code>__future__</code> 模块导入。如果你计划让你的代码支持 Python 3.x，建议你使用 <code>__future__</code> 模块导入。例如，如果我想要 在Python 2 中表现 Python 3.x 中的整除，我们可以通过如下导入</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</div></pre></td></tr></table></figure>

<p>　　更多的 <code>__future__</code> 模块可被导入的特性被列在下表中：</p>
<table>
<thead>
<tr>
<th><strong>feature</strong></th>
<th style="text-align:right"><strong>optional in</strong></th>
<th style="text-align:center"><strong>mandatory in</strong></th>
<th><strong>effect</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>nested_scopes</td>
<td style="text-align:right">2.1.0b1</td>
<td style="text-align:center">2.2</td>
<td><a href="http://legacy.python.org/dev/peps/pep-0227/" target="_blank" rel="external">PEP 227</a>: Statically Nested Scopes</td>
</tr>
<tr>
<td>generators</td>
<td style="text-align:right">2.2.0a1</td>
<td style="text-align:center">2.3</td>
<td><a href="http://legacy.python.org/dev/peps/pep-0255/" target="_blank" rel="external">PEP 255</a>: Simple Generators</td>
</tr>
<tr>
<td>division</td>
<td style="text-align:right">2.2.0a2</td>
<td style="text-align:center">3.0</td>
<td><a href="http://legacy.python.org/dev/peps/pep-0238/" target="_blank" rel="external">PEP 238</a>: Changing the Division Operator</td>
</tr>
<tr>
<td>absolute_import</td>
<td style="text-align:right">2.5.0a1</td>
<td style="text-align:center">3.0</td>
<td><a href="http://legacy.python.org/dev/peps/pep-0328/" target="_blank" rel="external">PEP 328</a>: Imports: Multi-Line and Absolute/Relative</td>
</tr>
<tr>
<td>with_statement</td>
<td style="text-align:right">2.5.0a1</td>
<td style="text-align:center">2.6</td>
<td><a href="http://www.python.org/dev/peps/pep-0343" target="_blank" rel="external">PEP 343</a>: The “with” Statement</td>
</tr>
<tr>
<td>print_function</td>
<td style="text-align:right">2.5.0a2</td>
<td style="text-align:center">3.0</td>
<td><a href="http://legacy.python.org/dev/peps/pep-3105/" target="_blank" rel="external">PEP 3105</a>: Make print a function</td>
</tr>
<tr>
<td>unicode_literals</td>
<td style="text-align:right">2.5.0a2</td>
<td style="text-align:center">3.0</td>
<td><a href="http://legacy.python.org/dev/peps/pep-3112/" target="_blank" rel="external">PEP 3112</a>: Bytes literals in Python 3000</td>
</tr>
</tbody>
</table>
<p>(Source: <a href="https://docs.python.org/2/library/future.html" target="_blank" rel="external">https://docs.python.org/2/library/future.html</a>)</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> platform <span class="keyword">import</span> python_version</div></pre></td></tr></table></figure>

<h2 id="print函数"><strong><code>print</code>函数</strong></h2>
<p>　　很琐碎，而 <code>print</code> 语法的变化可能是最广为人知的了，但是仍值得一提的是： Python 2 的 print 声明已经被 <code>print()</code> 函数取代了，这意味着我们必须包装我们想打印在小括号中的对象。<br>Python 2 不具有额外的小括号问题。但对比一下，如果我们按照 Python 2 的方式不使用小括号调用 <code>print</code> 函数，Python 3 将抛出一个语法异常（<code>SyntaxError</code>）。</p>
<p><strong><em>Python 2</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'Python'</span>, python_version()</div><div class="line"><span class="keyword">print</span> <span class="string">'Hello, World!'</span></div><div class="line">print(<span class="string">'Hello, World!'</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">"text"</span>, ; <span class="keyword">print</span> <span class="string">'print more text on the same line'</span></div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 2.7.6<br>Hello, World!<br>Hello, World!<br>text print more text on the same line</p>
<p><strong><em>Python 3</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">'Python'</span>, python_version())</div><div class="line">print(<span class="string">'Hello, World!'</span>)</div><div class="line">print(<span class="string">"some text,"</span>, end=<span class="string">""</span>) </div><div class="line">print(<span class="string">' print more text on the same line'</span>)</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 3.4.1<br>Hello, World!<br>some text, print more text on the same line</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'Hello, World!'</span></div></pre></td></tr></table></figure>

<p><em>run result:</em><br>  File “<ipython-input-3-139a7c5835bd>“, line 1<br>　　print ‘Hello, World!’<br>　　　　　　　　　　^<br>SyntaxError: invalid syntax</ipython-input-3-139a7c5835bd></p>
<p><strong>Note:</strong><br>　　以上通过 Python 2 使用 <code>Printing &quot;Hello, World&quot;</code> 是非常正常的，尽管如此，如果你有多个对象在小括号中，我们将创建一个元组，因为 <code>print</code> 在 Python 2 中是一个声明，而不是一个函数调用。</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'Python'</span>, python_version()</div><div class="line">print(<span class="string">'a'</span>, <span class="string">'b'</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">'a'</span>, <span class="string">'b'</span></div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 2.7.7<br>(‘a’, ‘b’)<br>a b</p>
<h2 id="整除"><strong>整除</strong></h2>
<p>　　如果你正在移植代码，这个变化是特别危险的。或者你在 Python 2 上执行 Python 3 的代码。因为这个整除的变化表现在它会被忽视（即它不会抛出语法异常）。<br>　　因此，我还是倾向于使用一个 <code>float(3)/2</code> 或 <code>3/2.0</code> 代替在我的 Python 3 脚本保存在 Python 2 中的 <code>3/2</code> 的一些麻烦（并且反而过来也一样，我建议在你的 Python 2 脚本中使用 <code>from __future__ import division</code>）<br>　　<br><strong><em>Python 2</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'Python'</span>, python_version()</div><div class="line"><span class="keyword">print</span> <span class="string">'3 / 2 ='</span>, <span class="number">3</span> / <span class="number">2</span></div><div class="line"><span class="keyword">print</span> <span class="string">'3 // 2 ='</span>, <span class="number">3</span> // <span class="number">2</span></div><div class="line"><span class="keyword">print</span> <span class="string">'3 / 2.0 ='</span>, <span class="number">3</span> / <span class="number">2.0</span></div><div class="line"><span class="keyword">print</span> <span class="string">'3 // 2.0 ='</span>, <span class="number">3</span> // <span class="number">2.0</span></div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 2.7.6<br>3 / 2 = 1<br>3 // 2 = 1<br>3 / 2.0 = 1.5<br>3 // 2.0 = 1.0</p>
<p><strong><em>Python 3</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">'Python'</span>, python_version())</div><div class="line">print(<span class="string">'3 / 2 ='</span>, <span class="number">3</span> / <span class="number">2</span>)</div><div class="line">print(<span class="string">'3 // 2 ='</span>, <span class="number">3</span> // <span class="number">2</span>)</div><div class="line">print(<span class="string">'3 / 2.0 ='</span>, <span class="number">3</span> / <span class="number">2.0</span>)</div><div class="line">print(<span class="string">'3 // 2.0 ='</span>, <span class="number">3</span> // <span class="number">2.0</span>)</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 3.4.1<br>3 / 2 = 1.5<br>3 // 2 = 1<br>3 / 2.0 = 1.5<br>3 // 2.0 = 1.0</p>
<h2 id="Unicode"><strong><code>Unicode</code></strong></h2>
<p>　　Python 2 有 ASCII str() 类型，<code>unicode()</code> 是单独的，不是 <code>byte</code> 类型。<br>　　现在， 在 Python 3，我们最终有了 <code>Unicode (utf-8)</code> 字符串，以及一个字节类：<code>byte</code> 和 <code>bytearrays</code>。</p>
<p><strong><em>Python 2</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'Python'</span>, python_version()</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 2.7.6</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> type(unicode(<span class="string">'this is like a python3 str type'</span>))</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>&lt; type ‘unicode’ &gt;</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> type(<span class="string">b'byte type does not exist'</span>)</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>&lt; type ‘str’ &gt;</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'they are really'</span> + <span class="string">b' the same'</span></div></pre></td></tr></table></figure>

<p><em>run result:</em><br>they are really the same</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> type(bytearray(<span class="string">b'bytearray oddly does exist though'</span>))</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>&lt; type ‘bytearray’ &gt;</p>
<p><strong><em>Python 3</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">'Python'</span>, python_version())</div><div class="line">print(<span class="string">'strings are now utf-8 \u03BCnico\u0394é!'</span>)</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 3.4.1<br>strings are now utf-8 μnicoΔé!</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">'Python'</span>, python_version(), end=<span class="string">""</span>)</div><div class="line">print(<span class="string">' has'</span>, type(<span class="string">b' bytes for storing data'</span>))</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 3.4.1 has &lt; class ‘bytes’ &gt;</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">'and Python'</span>, python_version(), end=<span class="string">""</span>)</div><div class="line">print(<span class="string">' also has'</span>, type(bytearray(<span class="string">b'bytearrays'</span>)))</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>and Python 3.4.1 also has &lt; class ‘bytearray’&gt;</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'note that we cannot add a string'</span> + <span class="string">b'bytes for data'</span></div></pre></td></tr></table></figure>

<p><em>run result:</em><br>-—————————————————————————————————————<br>TypeError                                 Traceback (most recent call last)<br>&lt; ipython-input-13-d3e8942ccf81&gt; in &lt; module&gt;()<br>——&gt; 1 ‘note that we cannot add a string’ + b’bytes for data’</p>
<p>TypeError: Can’t convert ‘bytes’ object to str implicitly</p>
<h2 id="xrange模块"><strong><code>xrange</code>模块</strong></h2>
<p>　　在 Python 2 中 <code>xrange()</code> 创建迭代对象的用法是非常流行的。比如： <code>for</code> 循环或者是列表/集合/字典推导式。<br>　　这个表现十分像生成器（比如。“惰性求值”）。但是这个 <code>xrange-iterable</code> 是无穷的，意味着你可以无限遍历。<br>　　由于它的惰性求值，如果你不得仅仅不遍历它一次，<code>xrange()</code> 函数 比 <code>range()</code> 更快（比如 <code>for</code> 循环）。尽管如此，对比迭代一次，不建议你重复迭代多次，因为生成器每次都从头开始。<br>　　在 Python 3 中，<code>range()</code> 是像 <code>xrange()</code> 那样实现以至于一个专门的 <code>xrange()</code> 函数都不再存在（在 Python 3 中 <code>xrange()</code> 会抛出命名异常）。</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> timeit</div><div class="line">n = <span class="number">10000</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_range</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">        <span class="keyword">pass</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_xrange</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</div><div class="line">        <span class="keyword">pass</span></div></pre></td></tr></table></figure>

<p><strong><em>Python 2</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'Python'</span>, python_version()</div><div class="line"><span class="keyword">print</span> <span class="string">'\ntiming range()'</span></div><div class="line">%timeit test_range(n)</div><div class="line"><span class="keyword">print</span> <span class="string">'\n\ntiming xrange()'</span></div><div class="line">%timeit test_xrange(n)</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 2.7.6</p>
<p>timing range()<br>1000 loops, best of 3: 433 µs per loop</p>
<p>timing xrange()<br>1000 loops, best of 3: 350 µs per loop</p>
<p><strong><em>Python 3</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">'Python'</span>, python_version())</div><div class="line">print(<span class="string">'\ntiming range()'</span>)</div><div class="line">%timeit test_range(n)</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 3.4.1</p>
<p>timing range()<br>1000 loops, best of 3: 520 µs per loop</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(xrange(<span class="number">10</span>))</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>-—————————————————————————————————————<br>NameError                                 Traceback (most recent call last)</p>
<p><ipython-input-5-5d8f9b79ea70> in <module>()<br>——&gt; 1 print(xrange(10))</module></ipython-input-5-5d8f9b79ea70></p>
<p>NameError: name ‘xrange’ is not defined</p>
<h2 id="Python3中的range对象的__contains__方法"><strong>Python3中的<code>range</code>对象的<code>__contains__</code>方法</strong></h2>
<p>　　另外一件值得一提的事情就是在 Python 3 中 <code>range</code> 有一个新的 <code>__contains__</code> 方法（感谢 Yuchen Ying 指出了这个），<code>__contains__</code> 方法可以加速 “查找” 在 Python 3.x 中显著的整数和布尔类型。</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">10000000</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">val_in_range</span><span class="params">(x, val)</span>:</span></div><div class="line">    <span class="keyword">return</span> val <span class="keyword">in</span> range(x)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">val_in_xrange</span><span class="params">(x, val)</span>:</span></div><div class="line">    <span class="keyword">return</span> val <span class="keyword">in</span> xrange(x)</div><div class="line">print(<span class="string">'Python'</span>, python_version())</div><div class="line"><span class="keyword">assert</span>(val_in_range(x, x/<span class="number">2</span>) == <span class="keyword">True</span>)</div><div class="line"><span class="keyword">assert</span>(val_in_range(x, x//<span class="number">2</span>) == <span class="keyword">True</span>)</div><div class="line">%timeit val_in_range(x, x/<span class="number">2</span>)</div><div class="line">%timeit val_in_range(x, x//<span class="number">2</span>)</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 3.4.1<br>1 loops, best of 3: 742 ms per loop<br>1000000 loops, best of 3: 1.19 µs per loop<br>　　<br>　　基于以上的 timeit 的结果，当它使一个整数类型，而不是浮点类型的时候，你可以看到执行查找的速度是 60000 倍快。尽管如此，因为 Python 2.x 的 <code>range</code> 或者是 <code>xrange</code> 没有一个 <code>__contains__</code> 方法，这个整数类型或者是浮点类型的查询速度不会相差太大。</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'Python'</span>, python_version()</div><div class="line"><span class="keyword">assert</span>(val_in_xrange(x, x/<span class="number">2.0</span>) == <span class="keyword">True</span>)</div><div class="line"><span class="keyword">assert</span>(val_in_xrange(x, x/<span class="number">2</span>) == <span class="keyword">True</span>)</div><div class="line"><span class="keyword">assert</span>(val_in_range(x, x/<span class="number">2</span>) == <span class="keyword">True</span>)</div><div class="line"><span class="keyword">assert</span>(val_in_range(x, x//<span class="number">2</span>) == <span class="keyword">True</span>)</div><div class="line">%timeit val_in_xrange(x, x/<span class="number">2.0</span>)</div><div class="line">%timeit val_in_xrange(x, x/<span class="number">2</span>)</div><div class="line">%timeit val_in_range(x, x/<span class="number">2.0</span>)</div><div class="line">%timeit val_in_range(x, x/<span class="number">2</span>)</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 2.7.7<br>1 loops, best of 3: 285 ms per loop<br>1 loops, best of 3: 179 ms per loop<br>1 loops, best of 3: 658 ms per loop<br>1 loops, best of 3: 556 ms per loop<br>　　<br>　　下面说下 <code>__contain__</code>方法并没有加入到 Python 2.x 中的证据：</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">'Python'</span>, python_version())</div><div class="line">range.__contains__</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 3.4.1</p>
<p>&lt; slot wrapper ‘<strong>contains</strong>‘ of ‘range’ objects &gt;</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'Python'</span>, python_version()</div><div class="line">range.__contains__</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 2.7.7</p>
<p>-—————————————————————————————————————<br>AttributeError                            Traceback (most recent call last)<br>&lt; ipython-input-7-05327350dafb&gt; in &lt; module&gt;()<br>      1 print ‘Python’, python<em>version()<br>——&gt; 2 range.`<em>_contains</em></em>`</p>
<p>AttributeError: ‘builtin<em>function<em>or_method’ object has no attribute `’__contains</em></em>‘`</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'Python'</span>, python_version()</div><div class="line">xrange.__contains__</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 2.7.7</p>
<p>-—————————————————————————————————————<br>AttributeError                            Traceback (most recent call last)<br>&lt; ipython-input-8-7d1a71bfee8e&gt; in &lt; module&gt;()<br>      1 print ‘Python’, python<em>version()<br>——&gt; 2 xrange.`<em>_contains</em></em>`</p>
<p>AttributeError: type object ‘xrange’ has no attribute <code>&#39;__contains__&#39;</code></p>
<p>　　<strong>注意在 Python 2 和 Python 3 中速度的不同</strong><br>　　有些人指出了 Python 3 的 <code>range()</code> 和 Python 2 的 <code>xrange()</code> 之间的速度不同。因为他们是用相同的方法实现的，因此期望相同的速度。尽管如此，这事实在于 Python 3 倾向于比 Python 2 运行的慢一点。</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_while</span><span class="params">()</span>:</span></div><div class="line">    i = <span class="number">0</span></div><div class="line">    <span class="keyword">while</span> i &lt; <span class="number">20000</span>:</div><div class="line">        i += <span class="number">1</span></div><div class="line">    <span class="keyword">return</span></div></pre></td></tr></table></figure>

<p><strong><em>Python 3</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">'Python'</span>, python_version())</div><div class="line">%timeit test_while()</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 3.4.1<br>100 loops, best of 3: 2.68 ms per loop</p>
<p><strong><em>Python 2</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'Python'</span>, python_version()</div><div class="line">%timeit test_while()</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 2.7.6<br>1000 loops, best of 3: 1.72 ms per loop</p>
<h2 id="Raising_exceptions"><strong>Raising exceptions</strong></h2>
<p>　　Python 2 接受新旧两种语法标记，在 Python 3 中如果我不用小括号把异常参数括起来就会阻塞（并且反过来引发一个语法异常）。</p>
<p><strong><em>Python 2</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'Python'</span>, python_version()</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 2.7.6</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">raise</span> IOError, <span class="string">"file error"</span></div></pre></td></tr></table></figure>

<p><em>run result:</em> </p>
<p>-—————————————————————————————————————<br>IOError                                   Traceback (most recent call last)<br>&lt; ipython-input-8-25f049caebb0&gt; in &lt; module&gt;()<br>——&gt; 1 raise IOError, “file error”</p>
<p>IOError: file error</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">raise</span> IOError(<span class="string">"file error"</span>)</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>-—————————————————————————————————————<br>IOError                                   Traceback (most recent call last)<br>&lt; ipython-input-9-6f1c43f525b2&gt; in &lt; module&gt;()<br>——&gt; 1 raise IOError(“file error”)</p>
<p>IOError: file error</p>
<p><strong><em>Python 3</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'Python'</span>, python_version()</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 3.4.1</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">raise</span> IOError, <span class="string">"file error"</span></div></pre></td></tr></table></figure>

<p><em>run result:</em> </p>
<p>  File “<ipython-input-10-25f049caebb0>“, line 1<br>    raise IOError, “file error”<br>　　　　　　^<br>SyntaxError: invalid syntax<br>　　<br>　　在 Python 3 中，可以这样抛出异常：</ipython-input-10-25f049caebb0></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">'Python'</span>, python_version())</div><div class="line"><span class="keyword">raise</span> IOError(<span class="string">"file error"</span>)</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 3.4.1</p>
<p>-—————————————————————————————————————<br>OSError                                   Traceback (most recent call last)<br>&lt; ipython-input-11-c350544d15da&gt; in &lt; module&gt;()<br>      1 print(‘Python’, python_version())<br>——&gt; 2 raise IOError(“file error”)</p>
<p>OSError: file error</p>
<h2 id="Handling_exceptions"><strong>Handling exceptions</strong></h2>
<p>　　在 Python 3 中处理异常也轻微的改变了，在 Python 3 中我们现在使用 <code>as</code> 作为关键词。</p>
<p><strong><em>Python 2</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'Python'</span>, python_version()</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    let_us_cause_a_NameError</div><div class="line"><span class="keyword">except</span> NameError, err:</div><div class="line">    <span class="keyword">print</span> err, <span class="string">'--&gt; our error message'</span></div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 2.7.6<br>name ‘let_us_cause_a_NameError’ is not defined —&gt; our error message</p>
<p><strong><em>Python 3</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">'Python'</span>, python_version())</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    let_us_cause_a_NameError</div><div class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> err:</div><div class="line">    print(err, <span class="string">'--&gt; our error message'</span>)</div></pre></td></tr></table></figure>

<p><em>run result:</em> </p>
<p>Python 3.4.1<br>name ‘let_us_cause_a_NameError’ is not defined —&gt; our error message</p>
<h2 id="next()函数_and_-next()方法"><strong><code>next()</code>函数 and <code>.next()</code>方法</strong></h2>
<p>　　因为 <code>next() (.next())</code> 是一个如此普通的使用函数（方法），这里有另外一个语法改变（或者是实现上改变了），值得一提的是：在 Python 2.7.5 中函数和方法你都可以使用，<code>next()</code> 函数在 Python 3 中一直保留着（调用 <code>.next()</code> 抛出属性异常）。</p>
<p><strong><em>Python 2</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'Python'</span>, python_version()</div><div class="line">my_generator = (letter <span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">'abcdefg'</span>)</div><div class="line">next(my_generator)</div><div class="line">my_generator.next()</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 2.7.6</p>
<p>‘b</p>
<p><strong><em>Python 3</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">'Python'</span>, python_version())</div><div class="line">my_generator = (letter <span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">'abcdefg'</span>)</div><div class="line">next(my_generator)</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 3.4.1</p>
<p>‘a’</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my_generator.next()</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>-—————————————————————————————————————<br>AttributeError                            Traceback (most recent call last)<br>&lt; ipython-input-14-125f388bb61b&gt; in &lt; module&gt;()<br>——&gt; 1 my_generator.next()</p>
<p>AttributeError: ‘generator’ object has no attribute ‘next’</p>
<h2 id="For循环变量和全局命名空间泄漏"><strong><code>For</code>循环变量和全局命名空间泄漏</strong></h2>
<p>　　好消息：在 Python 3.x 中 <code>for</code> 循环变量不会再导致命名空间泄漏。<br>　　在 Python 3.x 中做了一个改变，在 What’s New In Python 3.0 中有如下描述：<br>　　“列表推导不再支持 <code>[... for var in item1, item2, ...]</code> 这样的语法。使用 <code>[... for var in (item1, item2, ...)]</code> 代替。也需要提醒的是列表推导有不同的语义：  他们关闭了在 <code>list()</code> 构造器中的生成器表达式的语法糖, 并且特别是循环控制变量不再泄漏进周围的作用范围域.”</p>
<p><strong><em>Python 2</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'Python'</span>, python_version()</div><div class="line">i = <span class="number">1</span></div><div class="line"><span class="keyword">print</span> <span class="string">'before: i ='</span>, i</div><div class="line"><span class="keyword">print</span> <span class="string">'comprehension: '</span>, [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</div><div class="line"><span class="keyword">print</span> <span class="string">'after: i ='</span>, i</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 2.7.6<br>before: i = 1<br>comprehension:  [0, 1, 2, 3, 4]<br>after: i = 4</p>
<p><strong><em>Python 3</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">'Python'</span>, python_version())</div><div class="line">i = <span class="number">1</span></div><div class="line">print(<span class="string">'before: i ='</span>, i)</div><div class="line">print(<span class="string">'comprehension:'</span>, [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)])</div><div class="line">print(<span class="string">'after: i ='</span>, i)</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 3.4.1<br>before: i = 1<br>comprehension: [0, 1, 2, 3, 4]<br>after: i = 1</p>
<h2 id="比较不可排序类型"><strong>比较不可排序类型</strong></h2>
<p>　　在 Python 3 中的另外一个变化就是当对不可排序类型做比较的时候，会抛出一个类型错误。</p>
<p><strong><em>Python 2</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'Python'</span>, python_version()</div><div class="line"><span class="keyword">print</span> <span class="string">"[1, 2] &gt; 'foo' = "</span>, [<span class="number">1</span>, <span class="number">2</span>] &gt; <span class="string">'foo'</span></div><div class="line"><span class="keyword">print</span> <span class="string">"(1, 2) &gt; 'foo' = "</span>, (<span class="number">1</span>, <span class="number">2</span>) &gt; <span class="string">'foo'</span></div><div class="line"><span class="keyword">print</span> <span class="string">"[1, 2] &gt; (1, 2) = "</span>, [<span class="number">1</span>, <span class="number">2</span>] &gt; (<span class="number">1</span>, <span class="number">2</span>)</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 2.7.6<br>[1, 2] &gt; ‘foo’ =  False<br>(1, 2) &gt; ‘foo’ =  True<br>[1, 2] &gt; (1, 2) =  False</p>
<p><strong><em>Python 3</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">'Python'</span>, python_version())</div><div class="line">print(<span class="string">"[1, 2] &gt; 'foo' = "</span>, [<span class="number">1</span>, <span class="number">2</span>] &gt; <span class="string">'foo'</span>)</div><div class="line">print(<span class="string">"(1, 2) &gt; 'foo' = "</span>, (<span class="number">1</span>, <span class="number">2</span>) &gt; <span class="string">'foo'</span>)</div><div class="line">print(<span class="string">"[1, 2] &gt; (1, 2) = "</span>, [<span class="number">1</span>, <span class="number">2</span>] &gt; (<span class="number">1</span>, <span class="number">2</span>))</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 3.4.1</p>
<p>-—————————————————————————————————————<br>TypeError                                 Traceback (most recent call last)<br>&lt; ipython-input-16-a9031729f4a0&gt; in &lt; module&gt;()<br>      1 print(‘Python’, python_version())<br>——&gt; 2 print(“[1, 2] &gt; ‘foo’ = “, [1, 2] &gt; ‘foo’)<br>      3 print(“(1, 2) &gt; ‘foo’ = “, (1, 2) &gt; ‘foo’)<br>      4 print(“[1, 2] &gt; (1, 2) = “, [1, 2] &gt; (1, 2))</p>
<p>TypeError: unorderable types: list() &gt; str()</p>
<h2 id="通过input()解析用户的输入"><strong>通过<code>input()</code>解析用户的输入</strong></h2>
<p>　　幸运的是，在 Python 3 中已经解决了把用户的输入存储为一个 <code>str</code> 对象的问题。为了避免在 Python 2 中的读取非字符串类型的危险行为，我们不得不使用 <code>raw_input()</code> 代替。</p>
<p><strong><em>Python 2</em></strong><br>    Python 2.7.6<br>    [GCC 4.0.1 (Apple Inc. build 5493)] on darwin<br>    Type “help”, “copyright”, “credits” or “license” for more information.</p>
<pre><code><span class="input"><span class="prompt">&gt;&gt;&gt;</span> my_input = input(<span class="string">'enter a number: '</span>)</span>
<span class="input"><span class="prompt">
enter a number: 123

&gt;&gt;&gt;</span> type(my_input)</span>
&lt;type <span class="string">'int'</span>&gt;

<span class="input"><span class="prompt">&gt;&gt;&gt;</span> my_input = raw_input(<span class="string">'enter a number: '</span>)</span>
<span class="input"><span class="prompt">
enter a number: 123

&gt;&gt;&gt;</span> type(my_input)</span>
&lt;type <span class="string">'str'</span>&gt;
</code></pre><p><strong><em>Python 3</em></strong><br>    Python 3.4.1<br>    [GCC 4.2.1 (Apple Inc. build 5577)] on darwin<br>    Type “help”, “copyright”, “credits” or “license” for more information.</p>
<pre><code><span class="input"><span class="prompt">&gt;&gt;&gt;</span> my_input = input(<span class="string">'enter a number: '</span>)</span>
<span class="input"><span class="prompt">
enter a number: 123

&gt;&gt;&gt;</span> type(my_input)</span>
&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span>
</code></pre><h2 id="返回可迭代对象，而不是列表"><strong>返回可迭代对象，而不是列表</strong></h2>
<p>　　如果在 xrange 章节看到的，现在在 Python 3 中一些方法和函数返回迭代对象 — 代替 Python 2 中的列表<br>　　因为我们通常那些遍历只有一次，我认为这个改变对节约内存很有意义。尽管如此，它也是可能的，相对于生成器 —- 如需要遍历多次。它是不那么高效的。<br>　　而对于那些情况下，我们真正需要的是列表对象，我们可以通过 <code>list()</code> 函数简单的把迭代对象转换成一个列表。</p>
<p><strong><em>Python 2</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">'Python'</span>, python_version() </div><div class="line"><span class="keyword">print</span> range(<span class="number">3</span>) </div><div class="line"><span class="keyword">print</span> type(range(<span class="number">3</span>))</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 2.7.6<br>[0, 1, 2]<br>&lt; type ‘list’&gt;</p>
<p><strong><em>Python 3</em></strong></p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print(<span class="string">'Python'</span>, python_version())</div><div class="line">print(range(<span class="number">3</span>))</div><div class="line">print(type(range(<span class="number">3</span>)))</div><div class="line">print(list(range(<span class="number">3</span>)))</div></pre></td></tr></table></figure>

<p><em>run result:</em><br>Python 3.4.1<br>range(0, 3)<br>&lt; class ‘range’&gt;<br>[0, 1, 2]<br>　　<br>　　在 Python 3 中一些经常使用到的不再返回列表的函数和方法：</p>
<ul>
<li><code>zip()</code></li>
<li><code>map()</code></li>
<li><code>filter()</code></li>
<li>dictionary’s <code>.keys()</code> method</li>
<li>dictionary’s <code>.values()</code> method</li>
<li>dictionary’s <code>.items()</code> method</li>
</ul>
<h2 id="更多的关于_Python_2_和_Python_3_的文章"><strong>更多的关于 Python 2 和 Python 3 的文章</strong></h2>
<p>　　下面是我建议后续的关于 Python 2 和 Python 3 的一些好文章。</p>
<p><strong>移植到 Python 3</strong></p>
<ul>
<li><a href="https://wiki.python.org/moin/Python2orPython3" target="_blank" rel="external">Should I use Python 2 or Python 3 for my development activity?</a></li>
<li><a href="https://docs.python.org/3.0/whatsnew/3.0.html" target="_blank" rel="external">What’s New In Python 3.0</a></li>
<li><a href="http://python3porting.com/differences.html" target="_blank" rel="external">Porting to Python 3</a></li>
<li><a href="https://docs.python.org/3/howto/pyporting.html" target="_blank" rel="external">Porting Python 2 Code to Python 3</a></li>
<li><a href="http://nothingbutsnark.svbtle.com/my-view-on-the-current-state-of-python-3" target="_blank" rel="external">How keep Python 3 moving forward</a></li>
</ul>
<p><strong>Python 3 的拥护者和反对者</strong></p>
<ul>
<li><a href="http://asmeurer.github.io/python3-presentation/slides.html#1" target="_blank" rel="external">10 awesome features of Python that you can’t use because you refuse to upgrade to Python 3</a></li>
<li><a href="http://lucumr.pocoo.org/2014/5/12/everything-about-unicode/" target="_blank" rel="external">Everything you did not want to know about Unicode in Python 3</a></li>
<li><a href="https://medium.com/@deliciousrobots/5d2ad703365dverything-about-unicode/" target="_blank" rel="external">Python 3 is killing Python</a></li>
<li><a href="https://medium.com/@opinionbreaker/python-3-can-revive-python-2a7af4788b10" target="_blank" rel="external">Python 3 can revive Python</a></li>
<li><a href="http://sealedabstract.com/rants/python-3-is-fine/" target="_blank" rel="external">Python 3 is fine</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　因这学期负责Python课程的助教，刚开始上机试验的几节课，有很多同学用 Python3.4 的编译器编译 Python 2.7 的程序而导致不通过。Python 2.7.x 和 Python 3.x 版本并非完全兼容。<br>　　许多 Python 初学者想知道他们应]]>
    </summary>
    
      <category term="Python" scheme="http://chenqx.github.com/tags/Python/"/>
    
      <category term="Python" scheme="http://chenqx.github.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Scrapy爬虫抓取网站数据]]></title>
    <link href="http://chenqx.github.com/2014/11/09/Scrapy-Tutorial-for-BBSSpider/"/>
    <id>http://chenqx.github.com/2014/11/09/Scrapy-Tutorial-for-BBSSpider/</id>
    <published>2014-11-09T05:34:46.000Z</published>
    <updated>2014-11-29T13:21:36.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Scrapy_at_a_glance"><strong>Scrapy at a glance</strong></h2>
<p>　　Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中。<br>　　其最初是为了页面抓取 (更确切来说, 网络抓取 )所设计的， 也可以应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。</p>
<ul>
<li><a href="http://www.scrapy.org/" target="_blank" rel="external">官方主页</a></li>
<li><a href="http://doc.scrapy.org/en/0.24/index.html" target="_blank" rel="external">Scrapy 0.24 documentation</a></li>
<li><a href="https://github.com/scrapy/scrapy" target="_blank" rel="external">GitHub项目主页</a></li>
</ul>
<p>　　Scrapy 使用了 Twisted异步网络库来处理网络通讯。整体架构大致如下：<br><img src="http://newtonblogimg.qiniudn.com/Scrapy%20Architecture.png" alt="Scrapy Architecture"><br>　　Scrapy主要包括了以下组件：</p>
<ul>
<li><code>引擎</code>：用来处理整个系统的数据流处理，触发事务。</li>
<li><code>调度器</code>：用来接受引擎发过来的请求，压入队列中，并在引擎再次请求的时候返回。</li>
<li><code>下载器</code>：用于下载网页内容，并将网页内容返回给蜘蛛。</li>
<li><code>蜘蛛</code>：蜘蛛是主要干活的，用它来制订特定域名或网页的解析规则。</li>
<li><code>项目管道</code>：负责处理有蜘蛛从网页中抽取的项目，他的主要任务是清晰、验证和存储数据。当页面被蜘蛛解析后，将被发送到项目管道，并经过几个特定的次序处理数据。</li>
<li><code>下载器中间件</code>：位于Scrapy引擎和下载器之间的钩子框架，主要是处理Scrapy引擎与下载器之间的请求及响应。</li>
<li><code>蜘蛛中间件</code>：介于Scrapy引擎和蜘蛛之间的钩子框架，主要工作是处理蜘蛛的响应输入和请求输出。</li>
<li><code>调度中间件</code>：介于Scrapy引擎和调度之间的中间件，从Scrapy引擎发送到调度的请求和响应。</li>
</ul>
<p>　　使用Scrapy可以很方便的完成网上数据的采集工作，它为我们完成了大量的工作，而不需要自己费大力气去开发。</p>
<h2 id="Scrapy_Tutorial"><strong>Scrapy Tutorial</strong></h2>
<p>　　在本文中，假定您已经安装好<code>Scrapy</code>。 如若不然，请参考 <a href="http://doc.scrapy.org/en/0.24/intro/install.html#intro-install" target="_blank" rel="external"><em>Installation guide</em></a>。<br>　　接下来以爬取<a href="https://bbs.sjtu.edu.cn/frame2.html" target="_blank" rel="external"><em>饮水思源BBS</em></a>数据为例来讲述爬取过程，详见<a href="https://github.com/chenqx/spiderDemo/tree/master/SJTUbbsSpiderDemo" target="_blank" rel="external"><em> bbsdmoz代码</em></a>。<br>　　本篇教程中将带您完成下列任务：</p>
<pre><code><span class="bullet">1. </span>创建一个Scrapy项目
<span class="bullet">2. </span>定义提取的Item
<span class="bullet">3. </span>编写爬取网站的 spider 并提取 Item
<span class="bullet">4. </span>编写 Item Pipeline 来存储提取到的Item(即数据)
</code></pre><p>　　Scrapy由Python编写。如果您刚接触并且好奇这门语言的特性以及Scrapy的详情， 对于已经熟悉其他语言并且想快速学习Python的编程老手， 我们推荐 <a href="http://learnpythonthehardway.org/book/" target="_blank" rel="external">Learn Python The Hard Way</a> ， 对于想从Python开始学习的编程新手， <a href="https://wiki.python.org/moin/BeginnersGuide/NonProgrammers" target="_blank" rel="external">非程序员的Python学习资料列表 </a>将是您的选择。</p>
<h2 id="Creating_a_project"><strong>Creating a project</strong></h2>
<p>　　在开始爬取之前，您必须创建一个新的Scrapy项目。进入您打算存储代码的目录中，运行下列命令：</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy startproject bbsdmoz</div></pre></td></tr></table></figure>

<p>　　该命令将会创建包含下列内容的 bbsDmoz 目录：</p>
<pre><code>bbsDmoz/
scrapy.cfg
bbsDmoz/
    __init__.py
    items.py
    pipelines.py
    settings.py
    spiders/
        __init__.py
        <span class="keyword">...</span>
</code></pre><p>　　这些文件分别是：</p>
<ul>
<li><code>scrapy.cfg</code>: 项目的配置文件</li>
<li><code>bbsDmoz/</code>: 该项目的<code>python</code>模块。之后您将在此加入代码。</li>
<li><code>bbsDmoz/items.py</code>: 项目中的<code>item</code>文件.</li>
<li><code>bbsDmoz/pipelines.py</code>: 项目中的<code>pipelines</code>文件.</li>
<li><code>bbsDmoz/settings.py</code>: 项目的设置文件.</li>
<li><code>bbsDmoz/spiders/</code>: 放置<code>spider</code>代码的目录.</li>
</ul>
<h2 id="Defining_our_Item"><strong>Defining our Item</strong></h2>
<p>　　Item 是保存爬取到的数据的容器；其使用方法和python字典类似，并且提供了额外保护机制来避免拼写错误导致的未定义字段错误。<br>　　类似在ORM中做的一样，您可以通过创建一个 <code>scrapy.Item</code> 类，并且定义类型为 <code>scrapy.Field</code> 的类属性来定义一个Item。(如果不了解ORM,不用担心，您会发现这个步骤非常简单)<br>　　首先根据需要从bbs网站获取到的数据对item进行建模。 我们需要从中获取<em>url，发帖板块，发帖人，以及帖子的内容</em>。 对此，在item中定义相应的字段。编辑 bbsDmoz 目录中的 <code>items.py</code> 文件：</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="comment"># Define here the models for your scraped items</span></div><div class="line"><span class="comment"># See documentation in:</span></div><div class="line"><span class="comment"># http://doc.scrapy.org/en/latest/topics/items.html</span></div><div class="line"><span class="keyword">from</span> scrapy.item <span class="keyword">import</span> Item, Field</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BbsDmozItem</span><span class="params">(Item)</span>:</span></div><div class="line">    <span class="comment"># define the fields for your item here like:</span></div><div class="line">    <span class="comment"># name = scrapy.Field()</span></div><div class="line">    url   = Field()</div><div class="line">    forum = Field()</div><div class="line">    poster = Field()</div><div class="line">    content = Field()</div></pre></td></tr></table></figure>

<p>　　一开始这看起来可能有点复杂，但是通过定义item， 您可以很方便的使用Scrapy的其他方法。而这些方法需要知道您的item的定义。</p>
<h2 id="Our_first_Spider"><strong>Our first Spider</strong></h2>
<p>　　Spider是用户编写用于从单个网站(或者一些网站)爬取数据的类。<br>　　其包含了一个用于下载的初始URL，如何跟进网页中的链接以及如何分析页面中的内容， 提取生成 item 的方法。</p>
<h3 id="创建一个Spider">创建一个Spider</h3>
<p>　　为了创建一个Spider，保存在 bbsDmoz/spiders，您必须继承 scrapy.Spider 类，且定义以下三个属性:</p>
<ul>
<li><code>name</code>: 用于区别Spider。该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。</li>
<li><code>start_urls</code>: 包含了Spider在启动时进行爬取的url列表。因此，第一个被获取到的页面将是其中之一。后续的URL则从初始的URL获取到的数据中提取。我们可以利用正则表达式定义和过滤需要进行跟进的链接。</li>
<li><code>parse()</code> 是spider的一个方法。被调用时，每个初始URL完成下载后生成的 <code>Response</code> 对象将会作为唯一的参数传递给该函数。该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 <code>Request</code> 对象。</li>
</ul>
<h3 id="Selectors选择器">Selectors选择器</h3>
<p>　　从网页中提取数据有很多方法。Scrapy使用了一种基于  <a href="http://www.w3.org/TR/xpath/" target="_blank" rel="external">XPath</a> 和 <a href="http://www.w3.org/TR/selectors/" target="_blank" rel="external">CSS</a> 表达式机制： <a href="http://doc.scrapy.org/en/0.24/topics/selectors.html#topics-selectors" target="_blank" rel="external">Scrapy Selectors</a> 。 关于selector和其他提取机制的信息请参考 <a href="http://doc.scrapy.org/en/0.24/topics/selectors.html#topics-selectors" target="_blank" rel="external">Selector文档</a> 。<br>　　我们使用XPath来从页面的HTML源码中选择需要提取的数据。这里给出XPath表达式的例子及对应的含义:</p>
<ul>
<li><code>/html/head/title</code>: 选择HTML文档中 <code>&lt;head&gt;</code> 标签内的 <code>&lt;title&gt;</code> 元素</li>
<li><code>/html/head/title/text()</code>: 选择上面提到的 <code>&lt;title&gt;</code> 元素的文字</li>
<li><code>//td</code>: 选择所有的 <code>&lt;td&gt;</code> 元素</li>
<li><code>//div[@class=&quot;mine&quot;]</code>: 选择所有具有 <code>class=&quot;mine&quot;</code> 属性的 <code>div</code> 元素</li>
</ul>
<p>　　以饮水思源BBS一页面为例：<a href="https://bbs.sjtu.edu.cn/bbstcon?board=PhD&amp;reid=1406973178&amp;file=M.1406973178.A" target="_blank" rel="external">https://bbs.sjtu.edu.cn/bbstcon?board=PhD&amp;reid=1406973178&amp;file=M.1406973178.A</a><br>　　观察HTML页面源码并创建我们需要的数据(种子名字，描述和大小)的XPath表达式。<br>　　通过观察，我们可以发现<code>poster</code>是包含在 <code>pre/a</code> 标签中的，这里是<code>userid=jasperstream</code>:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="tag">&lt;<span class="title">pre</span>&gt;</span></div><div class="line">[<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">'bbspst?board=PhD&file=M.1406973178.A'</span>&gt;</span>回复本文<span class="tag">&lt;/<span class="title">a</span>&gt;</span>][<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">'bbscon?board=PhD&file=M.1406973178.A'</span>&gt;</span>原帖<span class="tag">&lt;/<span class="title">a</span>&gt;</span>] 发信人: <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"bbsqry?userid=jasperstream"</span>&gt;</span>jasperstream<span class="tag">&lt;/<span class="title">a</span>&gt;</span></div></pre></td></tr></table></figure>

<p>　　因此可以提取<code>jasperstream</code>的 XPath 表达式为：</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'//pre/a/text()'</span></div></pre></td></tr></table></figure>

<p>　　同理我可以提取其他内容的XPath，并最好在提取之后验证其正确性。上边仅仅是几个简单的XPath例子，XPath实际上要比这远远强大的多。 如果您想了解的更多，我们推荐 这篇XPath教程。<br>　　为了配合XPath，Scrapy除了提供了 Selector 之外，还提供了方法来避免每次从response中提取数据时生成selector的麻烦。<br>　　Selector有四个基本的方法(点击相应的方法可以看到详细的API文档):</p>
<ul>
<li><code>xpath()</code>: 传入xpath表达式，返回该表达式所对应的所有节点的<code>selector list</code>列表 。</li>
<li><code>css()</code>: 传入CSS表达式，返回该表达式所对应的所有节点的<code>selector list</code>列表.</li>
<li><code>extract()</code>: 序列化该节点为unicode字符串并返回<code>list</code>。</li>
<li><code>re()</code>: 根据传入的正则表达式对数据进行提取，返回unicode字符串list列表。</li>
</ul>
<p>　　如提取上述的<code>poster</code>的数据：</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sel.xpath(<span class="string">'//pre/a/text()'</span>).extract()</div></pre></td></tr></table></figure>

<h3 id="使用Item">使用Item</h3>
<p>　　<code>Item</code> 对象是自定义的python字典。您可以使用标准的字典语法来获取到其每个字段的值(字段即是我们之前用Field赋值的属性)。一般来说，Spider将会将爬取到的数据以 <code>Item</code> 对象返回。　</p>
<h3 id="Spider代码">Spider代码</h3>
<p>　　以下为我们的第一个<strong><code>Spider代码</code></strong>，保存在 <code>bbsDmoz/spiders</code> 目录下的 <code>forumSpider.py</code> 文件中：</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-*- coding: utf-8 -*-</span></div><div class="line"><span class="string">'''</span></div><div class="line">bbsSpider, Created on Oct, 2014</div><div class="line">#version: 1.0</div><div class="line">#author: chenqx @http://chenqx.github.com</div><div class="line">See more: http://doc.scrapy.org/en/latest/index.html</div><div class="line">'''</div><div class="line"><span class="keyword">from</span> scrapy.selector <span class="keyword">import</span> Selector</div><div class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span>  Request</div><div class="line"><span class="keyword">from</span> scrapy.contrib.spiders <span class="keyword">import</span> CrawlSpider</div><div class="line"><span class="keyword">from</span> scrapy.contrib.loader <span class="keyword">import</span> ItemLoader</div><div class="line"><span class="keyword">from</span> scrapy.contrib.linkextractors.sgml <span class="keyword">import</span> SgmlLinkExtractor</div><div class="line"><span class="keyword">from</span> bbs.items <span class="keyword">import</span> BbsItem</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">forumSpider</span><span class="params">(CrawlSpider)</span>:</span></div><div class="line"></div><div class="line">  <span class="comment"># name of spiders</span></div><div class="line">  name = <span class="string">'bbsSpider'</span></div><div class="line">  allow_domain = [<span class="string">'bbs.sjtu.edu.cn'</span>]</div><div class="line">  start_urls = [ <span class="string">'https://bbs.sjtu.edu.cn/bbsall'</span> ]</div><div class="line">  link_extractor = {</div><div class="line"></div><div class="line">      <span class="string">'page'</span>:  SgmlLinkExtractor(allow = <span class="string">'/bbsdoc,board,\w+\.html$'</span>),</div><div class="line"></div><div class="line">      <span class="string">'page_down'</span>:  SgmlLinkExtractor(allow = <span class="string">'/bbsdoc,board,\w+,page,\d+\.html$'</span>),</div><div class="line"></div><div class="line">      <span class="string">'content'</span>:  SgmlLinkExtractor(allow = <span class="string">'/bbscon,board,\w+,file,M\.\d+\.A\.html$'</span>),</div><div class="line">    }</div><div class="line">  </div><div class="line">  _x_query = {</div><div class="line"></div><div class="line">      <span class="string">'page_content'</span>:    <span class="string">'//pre/text()[2]'</span>,</div><div class="line"></div><div class="line">      <span class="string">'poster'</span>    :    <span class="string">'//pre/a/text()'</span>,</div><div class="line"></div><div class="line">      <span class="string">'forum'</span>    :    <span class="string">'//center/text()[2]'</span>,</div><div class="line">    }</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></div><div class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> self.link_extractor[<span class="string">'page'</span>].extract_links(response):</div><div class="line">      <span class="keyword">yield</span> Request(url = link.url, callback=self.parse_page)</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse_page</span><span class="params">(self, response)</span>:</span></div><div class="line">    </div><div class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> self.link_extractor[<span class="string">'page_down'</span>].extract_links(response):</div><div class="line">      <span class="keyword">yield</span> Request(url = link.url, callback=self.parse_page)</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> link <span class="keyword">in</span> self.link_extractor[<span class="string">'content'</span>].extract_links(response):</div><div class="line">      <span class="keyword">yield</span> Request(url = link.url, callback=self.parse_content)</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">parse_content</span><span class="params">(self, response)</span>:</span></div><div class="line"></div><div class="line">    bbsItem_loader = ItemLoader(item=BbsItem(), response = response)</div><div class="line">    url = str(response.url)</div><div class="line">    bbsItem_loader.add_value(<span class="string">'url'</span>, url)</div><div class="line">    bbsItem_loader.add_xpath(<span class="string">'forum'</span>, self._x_query[<span class="string">'forum'</span>])</div><div class="line">    bbsItem_loader.add_xpath(<span class="string">'poster'</span>, self._x_query[<span class="string">'poster'</span>])</div><div class="line">    bbsItem_loader.add_xpath(<span class="string">'content'</span>, self._x_query[<span class="string">'page_content'</span>])</div><div class="line"></div><div class="line">    <span class="keyword">return</span> bbsItem_loader.load_item()</div></pre></td></tr></table></figure>

<h2 id="Define_Item_Pipeline"><strong>Define Item Pipeline</strong></h2>
<p>　　当Item在Spider中被收集之后，它将会被传递到Item Pipeline，一些组件会按照一定的顺序执行对Item的处理。<br>　　每个item pipeline组件(有时称之为“Item Pipeline”)是实现了简单方法的Python类。他们接收到Item并通过它执行一些行为，同时也决定此Item是否继续通过pipeline，或是被丢弃而不再进行处理。<br>　　以下是<code>item pipeline</code>的一些典型应用：</p>
<ul>
<li>清理HTML数据</li>
<li>验证爬取的数据(检查item包含某些字段)</li>
<li>查重(并丢弃)</li>
<li>将爬取结果保存，如保存到数据库、XML、JSON等文件中</li>
</ul>
<h3 id="编写_Item_Pipeline">编写 Item Pipeline</h3>
<p>　　编写你自己的<code>item pipeline</code>很简单，每个<code>item pipeline</code>组件是一个独立的Python类，同时必须实现以下方法:</p>
<pre><code> process_item(item, spider)
　　每个item pipeline组件都需要调用该方法，这个方法必须返回一个 <span class="keyword">Item</span> (或任何继承类)对象，或是抛出 DropItem异常，被丢弃的item将不会被之后的pipeline组件所处理。
　　参数：item (<span class="keyword">Item</span> object) – 由 parse 方法返回的 <span class="keyword">Item</span> 对象
　　　　　spider (Spider object) – 抓取到这个 <span class="keyword">Item</span> 对象对应的爬虫对象
</code></pre><p>　　此外,他们也可以实现以下方法：</p>
<pre><code>open_spider(spider)
　　当spider被开启时，这个方法被调用。
　　参数: spider (Spider <span class="keyword">object</span>) – 被开启的spider
close_spider(spider)
　　当spider被关闭时，这个方法被调用，可以再爬虫关闭后进行相应的数据处理。
　　参数: spider (Spider <span class="keyword">object</span>) – 被关闭的spider
</code></pre><p>　　本文爬虫的<code>item pipeline</code>如下，保存为XML文件：</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="comment"># Define your item pipelines here</span></div><div class="line"><span class="comment"># Don't forget to add your pipeline to the ITEM_PIPELINES setting</span></div><div class="line"><span class="comment"># See: http://doc.scrapy.org/en/latest/topics/item-pipeline.html</span></div><div class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> signals</div><div class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> log</div><div class="line"><span class="keyword">from</span> bbsDmoz.items <span class="keyword">import</span> BbsDmozItem</div><div class="line"><span class="keyword">from</span> twisted.enterprise <span class="keyword">import</span> adbapi</div><div class="line"><span class="keyword">from</span> scrapy.contrib.exporter <span class="keyword">import</span> XmlItemExporter</div><div class="line"><span class="keyword">from</span> dataProcess <span class="keyword">import</span> dataProcess</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">XmlWritePipeline</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line">    <span class="decorator">@classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_crawler</span><span class="params">(cls, crawler)</span>:</span></div><div class="line">        pipeline = cls()</div><div class="line">        crawler.signals.connect(pipeline.spider_opened, signals.spider_opened)</div><div class="line">        crawler.signals.connect(pipeline.spider_closed, signals.spider_closed)</div><div class="line">        <span class="keyword">return</span> pipeline</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spider_opened</span><span class="params">(self, spider)</span>:</span></div><div class="line">        self.file = open(<span class="string">'bbsData.xml'</span>, <span class="string">'wb'</span>)</div><div class="line">        self.expoter = XmlItemExporter(self.file)</div><div class="line">        self.expoter.start_exporting()</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spider_closed</span><span class="params">(self, spider)</span>:</span></div><div class="line">        self.expoter.finish_exporting()</div><div class="line">        self.file.close()</div><div class="line">        <span class="comment"># process the crawled data, define and call dataProcess function</span></div><div class="line">        <span class="comment"># dataProcess('bbsData.xml', 'text.txt')</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></div><div class="line">        self.expoter.export_item(item)</div><div class="line">        <span class="keyword">return</span> item</div></pre></td></tr></table></figure>

<h3 id="启用和设置_Item_Pipeline">启用和设置 Item Pipeline</h3>
<p>　　为了启用一个<code>Item Pipeline</code>组件，你必须将它的类添加到 <code>ITEM_PIPELINES</code> 就像下面这个例子：</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ITEM_PIPELINES = {</div><div class="line">    <span class="string">'bbsDmoz.pipelines.XmlWritePipeline'</span>: <span class="number">1000</span>,</div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　分配给每个类的整型值，确定了他们运行的顺序，item按数字从低到高的顺序，通过pipeline，通常将这些数字定义在0-1000范围内。</p>
<h2 id="Settings"><strong>Settings</strong></h2>
<p>　　Scrapy设定(<code>settings</code>)提供了定制Scrapy组件的方法。您可以控制包括核心(core)，插件(extension)，pipeline及spider组件。<br>　　设定为代码提供了提取以key-value映射的配置值的的全局命名空间(namespace)。 设定可以通过下面介绍的多种机制进行设置。<br>　　设定(settings)同时也是选择当前激活的Scrapy项目的方法(如果您有多个的话)。<br>　　在<code>setting</code>配置文件中，你可一定以抓取的速率、是否在桌面显示抓取过程信息等。详细请参考<a href="http://scrapy-zh.likedoc.net/zh_CN/latest/topics/settings.html#topics-settings-ref" target="_blank" rel="external">内置设定列表请参考</a> 。<br>　　本爬虫的<code>setting</code>配置如下：</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="comment"># Scrapy settings for bbs project</span></div><div class="line"><span class="comment"># For simplicity, this file contains only the most important settings by</span></div><div class="line"><span class="comment"># default. All the other settings are documented here:</span></div><div class="line"><span class="comment"># http://doc.scrapy.org/en/latest/topics/settings.html</span></div><div class="line">BOT_NAME = <span class="string">'bbsDomz'</span></div><div class="line">CONCURRENT_REQUESTS = <span class="number">200</span></div><div class="line">LOG_LEVEL = <span class="string">'INFO'</span></div><div class="line">COOKIES_ENABLED = <span class="keyword">True</span></div><div class="line">RETRY_ENABLED = <span class="keyword">True</span></div><div class="line">SPIDER_MODULES = [<span class="string">'bbsDomz.spiders'</span>]</div><div class="line">NEWSPIDER_MODULE = <span class="string">'bbsDomz.spiders'</span></div><div class="line"><span class="comment"># JOBDIR = 'jobdir'</span></div><div class="line">ITEM_PIPELINES = {</div><div class="line">    <span class="string">'bbsDomz.pipelines.XmlWritePipeline'</span>: <span class="number">1000</span>,</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="Crawling"><strong>Crawling</strong></h2>
<p>　　写好爬虫程序后，我们就可以运行程序抓取数据。进入项目的根目录<code>bbsDomz/</code>下，执行下列命令启动spider：</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy crawl bbsSpider</div></pre></td></tr></table></figure>

<p>　　这样就等程序运行结束就还可以啦。</p>
<h2 id="Further_reading"><strong>Further reading</strong></h2>
<ul>
<li><a href="http://doc.scrapy.org/en/0.24/index.html" target="_blank" rel="external">Scrapy 0.24 documentation</a></li>
<li><a href="http://blog.pluskid.org/?p=366&amp;cpage=1" target="_blank" rel="external">Scrapy 轻松定制网络爬虫</a><br><img src="/img/blogImage/pacman.jpg" alt="The End"></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Scrapy_at_a_glance"><strong>Scrapy at a glance</strong></h2>
<p>　　Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘，信息处理或存储历史数据等一系列的程序中]]>
    </summary>
    
      <category term="Python" scheme="http://chenqx.github.com/tags/Python/"/>
    
      <category term="Scrapy" scheme="http://chenqx.github.com/tags/Scrapy/"/>
    
      <category term="Python" scheme="http://chenqx.github.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[文本挖掘]]></title>
    <link href="http://chenqx.github.com/2014/11/01/Text-Mining/"/>
    <id>http://chenqx.github.com/2014/11/01/Text-Mining/</id>
    <published>2014-11-01T07:56:48.000Z</published>
    <updated>2014-11-13T07:03:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Introduction"><strong>Introduction</strong></h2>
<h3 id="简介_">简介　</h3>
<p>　　在现实世界中，可获取的大部信息是以文本形式存储在文本数据库中的，由来自各种数据源的大量文档组成，如新闻文档、研究论文、书籍、数字图书馆、电子邮件和Web页面。由于电子形式的文本信息飞速增涨，文本挖掘已经成为信息领域的研究热点。<br>　　文本数据库中存储的数据可能是高度非结构化的，如WWW上的网页。也可能是半结构化的，如e-mail消息和一些XML网页：而其它的则可能是良结构化的。良结构化文本数据的典型代表是图书馆数据库中的文档，这些文档可能包含结构字段，如标题、作者、出版日期、长度、分类等等，也可能包含大量非结构化文本成分，如摘要和内容。通常，具有较好结构的文本数据库可以使用关系数据库系统实现，而对非结构化的文本成分需要采用特殊的处理方法对其进行转化。<br>　　文本挖掘(Text Mining)是一个从非结构化文本信息中获取用户感兴趣或者有用的模式的过程。其中被普遍认可的文本挖掘定义如下：文本挖掘是指从大量文本数据中抽取事先未知的、可理解的、最终可用的知识的过程，同时运用这些知识更好地组织信息以便将来参考。<br>　　文本挖掘的主要用途是从原本未经处理的文本中提取出未知的知识，但是文本挖掘也是一项非常困难的工作,因为它必须处理那些本来就模糊而且非结构化的文本数据,所以它是一个多学科混杂的领域,涵盖了信息技术、文本分析、模式识别、统计学、数据可视化、数据库技术、机器学习以及数据挖掘等技术 。文本挖掘是从数据挖掘发展而来，因此其定义与我们熟知的数据挖掘定义相类似。但与传统的数据挖掘相比，文本挖掘有其独特之处，主要表现在:文档本身是半结构化或非结构化的，无确定形式并且缺乏机器可理解的语义;而数据挖掘的对象以数据库中的结构化数据为主，并利用关系表等存储结构来发现知识。因此，有些数据挖掘技术并不适用于文本挖掘，即使可用，也需要建立在对文本集预处理的基础之上。<br>　　文本挖掘是应用驱动的。它在商业智能、信息检索、生物信息处理等方面都有广泛的应用；例如，客户关系管理，自动邮件回复，垃圾邮件过滤，自动简历评审，搜索引擎等等。</p>
<h3 id="基本步骤">基本步骤</h3>
<p>　　有些人把文本挖掘视为另一常用术语文本知识发现(KDD)的同义词，而另一些人只是把文本挖掘视为文本知识发现过程的一个基本步骤。文本知识发现主要由以下步骤组成：</p>
<blockquote>
<ol>
<li>获取文本数据源</li>
<li>文本预处理</li>
<li>挖掘与分析</li>
<li>评估与可视化</li>
</ol>
</blockquote>
<p><img src="http://newtonblogimg.qiniudn.com/textminingflowchart.jpg" alt="Text Mining Flow Chart"><br>　　本篇文章将在接下来的篇幅中，详细的介绍以上几个步骤。</p>
<h2 id="获取文本数据源"><strong>获取文本数据源</strong></h2>
<p>　　各文档数据库，语料库，论文集<br>　　web网页，如通过爬虫抓取，RSS订阅<br>　　<br>　　等</p>
<h2 id="文本预处理"><strong>文本预处理</strong></h2>
<h3 id="文本数据预处理">文本数据预处理</h3>
<p>去标签，去停用词，分词，生成数据集</p>
<h3 id="特征表达">特征表达</h3>
<p>　　<strong>常用表达模型</strong><br>　　特征表达模型种类较多，大体可分为基于集合论的模型、基于代数论的模型和基于概率统计的模型。下面将分别介绍其中比较有代表性和常用的模型。</p>
<h4 id="布尔模型"><em><code>布尔模型</code></em></h4>
<p>　　布尔模型（Bool model）。一个文档表示为文档中出现特征词的集合，也可以表示为一个特征空间上的向量，向量空间的每个分量的权值为0或1。</p>
<blockquote>
<p></p><p style="background:#f1f1f1"><em>例</em><br>　　词条数据集 wordset = [‘love’, ‘have’, ‘dream’]<br>　　文档1： doc_1 = [‘I’, ‘have’, ‘a’, ‘dream’]<br>　　文档2： doc_2= [‘Cats’, ‘love’, ‘fish’]<br>　　那么文档1的布尔模型表达为vector_doc_1 = (0, 1, 0, 1)，同理文档2的布尔模型表达为vector_doc_2 = (0, 1, 0, 0)</p>
</blockquote>
<h4 id="向量空间模型"><em><code>向量空间模型</code></em></h4>
<p>　　向量空间模型（VSM：Vector Space Model） (或者 词组向量模型) 作为向量的标识符（比如索引），是一个用来表示文本文件的代数模型。如词频向量模型，TF/IDF权重模型。</p>
<blockquote>
<p></p><p style="background:#f1f1f1"><em>例</em><br>词频向量模型<br>　　词条数据集 words = [‘love’, ‘have’, ‘dream’]<br>　　文档1： doc_1 = [‘I’, ‘have’, ‘a’, ‘dream’]<br>　　文档2： doc_2= [‘Cats’, ‘love’, ‘fish’]<br>　　那么文档1的布尔模型表达为vector_doc_1 = (0, 1, 0, 1)，同理文档2的布尔模型表达为vector_doc_2 = (0, 1, 0, 0)<br>　　<br>TF/IDF权重模型
　</p>
</blockquote>
<h4 id="Logistic回归模型"><em><code>Logistic回归模型</code></em></h4>
<p>　　基本思想：为了求 P(R=1|Q,D)，定义多个特征函数fi(Q,D),认为求 P(R=1|Q,D)是这些函数的组合。<br>　　通过训练集合拟合得到相应的系数，对于新的文档带入公式得到概率 P。</p>
<h3 id="特征提取">特征提取</h3>
<h4 id="开方检验"><em><code>开方检验</code></em></h4>
<p>　　　</p>
<h4 id="信息增益"><em><code>信息增益</code></em></h4>
<p>　　前文提到过，除了开方检验（CHI）以外，信息增益（IG，Information Gain）也是很有效的特征选择方法。信息增益（Kullback–Leibler divergence）又称information divergence，information gain，relative entropy 或者KLIC。但凡是特征选择，总是在将特征的重要程度量化之后再进行选择，而如何量化特征的重要性，就成了各种方法间最大的不同。开方检验中使用特征与类别间的关联性来进行这个量化，关联性越强，特征得分越高，该特征越应该被保留。<br>　　在信息增益中，衡量标准是看特征能够为分类系统带来多少信息，带来的信息越多，该特征越重要。对一个特征而言，系统有它和没它时信息量将发生变化，而前后信息量的差值就是这个特征给系统带来的信息量。所谓信息量，就是熵。<br>　　假如有变量X，分别是x1，x2，……，xn，每一种取到的概率分别是P1，P2，……，Pn，，那么X的熵就定义为：<br><img src="http://newtonblogimg.qiniudn.com/Entropy.png" alt=""><br>　　也就是说X可能的变化越多，X所携带的信息量越大，熵也就越大。对于文本分类或聚类而言，就是说文档属于哪个类别的变化越多，类别的信息量就越大。所以特征T给聚类C或分类C带来的信息增益为IG(T)=H(C)-H(C|T)。<br>　　H(C|T)包含两种情况：一种是特征T出现，标记为t，一种是特征T不出现，标记为t’。所以H(C|T)=P(t)H(C|t) + P(t’)H(C|t’)，再由熵的计算公式便可推得特征与类别的信息增益公式。<br>　　信息增益最大的问题在于它只能考察特征对整个系统的贡献，而不能具体到某个类别上，这就使得它只适合用来做所谓“全局”的特征选择（指所有的类都使用相同的特征集合），而无法做“本地”的特征选择（每个类别有自己的特征集合，因为有的词，对这个类别很有区分度，对另一个类别则无足轻重）。</p>
<h3 id="特征降维">特征降维</h3>
<h4 id="主成分分析"><em><code>主成分分析</code></em></h4>
<p>　　主成分分析（Principal Component Analysis，PCA）， 将多个变量通过线性变换以选出较少个数重要变量的一种多元统计分析方法。又称主分量分析。在很多情形，变量之间是有一定的相关关系的，当两个变量之间有一定相关关系时，可以解释为这两个变量反映某特征的信息有一定的重叠。PCA通过少数几个主成分来揭示多个变量间的内部结构，即从原始变量中导出少数几个主成分，将许多相关性较高的变量转化成彼此相互独立或不相关的变量，并使它们尽可能多地保留原始变量的信息。
　
　　　
　　　</p>
<h4 id="线性判别分析"><em><code>线性判别分析</code></em></h4>
<p>　　线性判别式分析(Linear Discriminant Analysis, LDA)，也叫做Fisher线性判别(Fisher Linear Discriminant ，FLD)。LDA基本思想是将高维的模式样本投影到最佳鉴别矢量空间，以达到抽取分类信息和压缩特征空间维数的效果，投影后保证模式样本在新的子空间有最大的类间距离和最小的类内距离，即模式在该空间中有最佳的可分离性。因此，它是一种有效的特征抽取方法。使用这种方法能够使投影后模式样本的类间散布矩阵最大，并且同时类内散布矩阵最小。就是说，它能够保证投影后模式样本在新的空间中有最小的类内距离和最大的类间距离，即模式在该空间中有最佳的可分离性。</p>
<h2 id="挖掘与分析"><strong>挖掘与分析</strong></h2>
<h3 id="文本分类与聚类">文本分类与聚类</h3>
<h3 id="信息抽取">信息抽取</h3>
<h3 id="关系抽取">关系抽取</h3>
<h3 id="关联分析">关联分析</h3>
<h2 id="评估与可视化"><strong>评估与可视化</strong></h2>
<h3 id="评估">评估</h3>
<h3 id="可视化">可视化</h3>
<h2 id="Conclusion"><strong>Conclusion</strong></h2>
<h2 id="References"><strong>References</strong></h2>
<p>[1] Ronen Feldman and James Sanger, The Text Mining Handbook, Cambridge University Press.<br>[2] Kao Anne, Poteet, Steve R. (Editors), Natural Language Processing and Text Mining, Springer.</p>
<p><img src="/img/blogImage/pacman.jpg" alt="The End"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Introduction"><strong>Introduction</strong></h2>
<h3 id="简介_">简介　</h3>
<p>　　在现实世界中，可获取的大部信息是以文本形式存储在文本数据库中的，由来自各种数据源的大量文档组成，如新闻文档、研究]]>
    </summary>
    
      <category term="Text Mining" scheme="http://chenqx.github.com/tags/Text-Mining/"/>
    
      <category term="NLP" scheme="http://chenqx.github.com/tags/NLP/"/>
    
      <category term="Machine Learning" scheme="http://chenqx.github.com/tags/Machine-Learning/"/>
    
      <category term="Data Mining" scheme="http://chenqx.github.com/categories/Data-Mining/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python读取大文件(GB)]]></title>
    <link href="http://chenqx.github.com/2014/10/29/Python-fastest-way-to-read-a-large-file/"/>
    <id>http://chenqx.github.com/2014/10/29/Python-fastest-way-to-read-a-large-file/</id>
    <published>2014-10-29T02:34:59.000Z</published>
    <updated>2014-11-11T02:12:37.000Z</updated>
    <content type="html"><![CDATA[<p>　　最近处理文本文档时（文件约2GB大小），出现<code>memoryError</code>错误和文件读取太慢的问题，后来找到了两种比较快<code>Large File Reading</code> 的方法，本文将介绍这两种读取方法。</p>
<h2 id="Preliminary"><strong>Preliminary</strong></h2>
<p>　　我们谈到“文本处理”时，我们通常是指处理的内容。Python 将文本文件的内容读入可以操作的字符串变量非常容易。文件对象提供了三个“读”方法： <code>.read()</code>、<code>.readline()</code> 和 <code>.readlines()</code>。每种方法可以接受一个变量以限制每次读取的数据量，但它们通常不使用变量。 <code>.read()</code> 每次读取整个文件，它通常用于将文件内容放到一个字符串变量中。然而 <code>.read()</code> 生成文件内容最直接的字符串表示，但对于连续的面向行的处理，它却是不必要的，并且如果文件大于可用内存，则不可能实现这种处理。下面是<code>read()</code>方法示例：</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    f = open(<span class="string">'/path/to/file'</span>, <span class="string">'r'</span>)</div><div class="line">    <span class="keyword">print</span> f.read()</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    <span class="keyword">if</span> f:</div><div class="line">        f.close()</div></pre></td></tr></table></figure>

<p>　　调用<code>read()</code>会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用<code>read(size)</code>方法，每次最多读取size个字节的内容。另外，调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。<br>　　如果文件很小，<code>read()</code>一次性读取最方便；如果不能确定文件大小，反复调用<code>read(size)</code>比较保险；如果是配置文件，调用<code>readlines()</code>最方便：</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</div><div class="line">    process(line) <span class="comment"># &lt;do something with line&gt;</span></div></pre></td></tr></table></figure>

<h2 id="Read_In_Chunks"><strong>Read In Chunks</strong></h2>
<p>　　处理大文件是很容易想到的就是将大文件分割成若干小文件处理，处理完每个小文件后释放该部分内存。这里用了 <code>iter &amp; yield</code>：</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_in_chunks</span><span class="params">(filePath, chunk_size=<span class="number">1024</span>*<span class="number">1024</span>)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Lazy function (generator) to read a file piece by piece.</div><div class="line">    Default chunk size: 1M</div><div class="line">    You can set your own chunk size </div><div class="line">    """</div><div class="line">    file_object = open(filePath)</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        chunk_data = file_object.read(chunk_size)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> chunk_data:</div><div class="line">            <span class="keyword">break</span></div><div class="line">        <span class="keyword">yield</span> chunk_data</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line"></div><div class="line">    filePath = <span class="string">'./path/filename'</span></div><div class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> read_in_chunks(filePath):</div><div class="line">        process(chunk) <span class="comment"># &lt;do something with chunk&gt;</span></div></pre></td></tr></table></figure>

<h2 id="Using_with_open()"><strong>Using <em><code>with open()</code></em></strong></h2>
<p>　　<code>with</code>语句打开和关闭文件，包括抛出一个内部块异常。<code>for line in f</code>文件对象<code>f</code>视为一个迭代器，会自动的采用缓冲<code>IO</code>和内存管理，所以你不必担心大文件。</p>
<figure class="highlight Python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#If the file is line based</span></div><div class="line"><span class="keyword">with</span> open(...) <span class="keyword">as</span> f:</div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">        process(line) <span class="comment"># &lt;do something with line&gt;</span></div></pre></td></tr></table></figure>

<h2 id="Conclusion"><strong>Conclusion</strong></h2>
<p>　　在使用python进行大文件读取时，应该让系统来处理，使用最简单的方式，交给解释器，就管好自己的工作就行了。<br>　　<br><img src="/img/blogImage/pacman.jpg" alt="The End"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　最近处理文本文档时（文件约2GB大小），出现<code>memoryError</code>错误和文件读取太慢的问题，后来找到了两种比较快<code>Large File Reading</code> 的方法，本文将介绍这两种读取方法。</p>
<h2 id="Prel]]>
    </summary>
    
      <category term="Python" scheme="http://chenqx.github.com/tags/Python/"/>
    
      <category term="Python" scheme="http://chenqx.github.com/categories/Python/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Natural Language Processing]]></title>
    <link href="http://chenqx.github.com/2014/10/25/Natural-Language-Processing/"/>
    <id>http://chenqx.github.com/2014/10/25/Natural-Language-Processing/</id>
    <published>2014-10-25T02:31:58.000Z</published>
    <updated>2014-11-11T11:12:11.000Z</updated>
    <content type="html"><![CDATA[<p>　　Building…</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　Building…</p>
]]>
    </summary>
    
      <category term="NLP" scheme="http://chenqx.github.com/tags/NLP/"/>
    
      <category term="NLP" scheme="http://chenqx.github.com/categories/NLP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MongoDB 介绍]]></title>
    <link href="http://chenqx.github.com/2014/10/16/MongoDB-Introduction/"/>
    <id>http://chenqx.github.com/2014/10/16/MongoDB-Introduction/</id>
    <published>2014-10-16T02:31:58.000Z</published>
    <updated>2014-11-21T12:02:43.000Z</updated>
    <content type="html"><![CDATA[<p>　　Updating…</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　Updating…</p>
]]>
    </summary>
    
      <category term="Database" scheme="http://chenqx.github.com/tags/Database/"/>
    
      <category term="Database" scheme="http://chenqx.github.com/categories/Database/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Machine Learning Overview]]></title>
    <link href="http://chenqx.github.com/2014/10/10/Machine-Learning-Overview/"/>
    <id>http://chenqx.github.com/2014/10/10/Machine-Learning-Overview/</id>
    <published>2014-10-10T02:31:57.000Z</published>
    <updated>2014-11-13T07:02:52.000Z</updated>
    <content type="html"><![CDATA[<p>　　<a href="http://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0" target="_blank" rel="external">机器学习</a>是近20多年兴起的一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。机器学习理论主要是设计和分析一些让计算机可以自动“学习”的算法。机器学习算法是一类从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法。因为学习算法中涉及了大量的统计学理论，机器学习与统计推断学联系尤为密切，也被称为统计学习理论。算法设计方面，机器学习理论关注可以实现的，行之有效的学习算法。很多推论问题属于无程序可循难度，所以部分的机器学习研究是开发容易处理的近似算法。<br>　　机器学习已经有了十分广泛的应用，例如：数据挖掘、计算机视觉、自然语言处理、生物特征识别、搜索引擎、医学诊断、检测信用卡欺诈、证券市场分析、DNA序列测序、语音和手写识别、战略游戏和机器人运用。<br>　　机器学习有下面几种定义： “机器学习是一门人工智能的科学，该领域的主要研究对象是人工智能，特别是如何在经验学习中改善具体算法的性能”。 “机器学习是对能通过经验自动改进的计算机算法的研究”。 “机器学习是用数据或以往的经验，以此优化计算机程序的性能标准。” 一种经常引用的英文定义是：</p>
<blockquote>
<p>　　<em>A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.</em></p>
</blockquote>
<p>Updating…</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　<a href="http://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0" target="_blank" rel="external">机器学习</a>是近20多年兴起的一门多领域交叉学科，涉]]>
    </summary>
    
      <category term="Machine Learning" scheme="http://chenqx.github.com/tags/Machine-Learning/"/>
    
      <category term="Data Mining" scheme="http://chenqx.github.com/tags/Data-Mining/"/>
    
      <category term="Machine Learning" scheme="http://chenqx.github.com/categories/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java设计模式：单例模式]]></title>
    <link href="http://chenqx.github.com/2014/10/01/Java-Design-Pattern-Singleton-Pattern/"/>
    <id>http://chenqx.github.com/2014/10/01/Java-Design-Pattern-Singleton-Pattern/</id>
    <published>2014-10-01T03:33:37.000Z</published>
    <updated>2014-11-14T12:40:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="单例模式介绍">单例模式介绍</h2>
<p>　　单例模式最初的定义出现于《设计模式》（艾迪生维斯理, 1994）：</p>
<blockquote>
<p><em>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</em></p>
</blockquote>
<p>　　<strong><a href="http://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">单例模式</a></strong>，也叫单子模式，是一种简单和常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。<br>　　单例模式主要有3个特点：</p>
<pre><code>(1). 单例类确保自己只有一个实例。
(2). 单例类必须自己创建自己的实例。
(3). 单例类必须为其他对象提供唯一的实例。
</code></pre><p>　　实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用<code>getInstance</code>这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。<br>　　单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 </p>
<h2 id="Java中单例模式的写法">Java中单例模式的写法</h2>
<p>　　单例模式是Java中最常用的模式之一，它通过阻止外部实例化和修改，来控制所创建的对象的数量。这个概念可以被推广到仅有一个对象能更高效运行的系统，或者限制对象实例化为特定的数目的系统中(From:<a href="http://www.programcreek.com/2011/07/java-design-pattern-singleton/" target="_blank" rel="external">Java Design Pattern: Singleton</a>)。例如：</p>
<ul>
<li>私有构造函数 - 其他类不能实例化一个新的对象。</li>
<li>私有化引用 - 不能进行外部修改。</li>
<li>公有静态方法是唯一可以获得对象的方式。</li>
</ul>
<p>　　单例模式的实现方式有五种方法：懒汉，恶汉，静态内部类，枚举和双重校验锁。</p>
<h3 id="懒汉方式">懒汉方式</h3>
<p>　　<strong>懒汉方式</strong>，指全局的单例实例在第一次被使用时构建。注意线程安全与否。</p>
<p>　　<em>线程不安全</em></p>
<figure class="highlight Java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Non Thread Safe</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </div><div class="line">    <span class="keyword">private</span> <span class="title">Singleton</span> (){}  </div><div class="line">  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {  </div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {  </div><div class="line">            instance = <span class="keyword">new</span> Singleton();  </div><div class="line">        }  </div><div class="line">    <span class="keyword">return</span> instance;  </div><div class="line">    }  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　这种写法<code>lazy loading</code>很明显，但是致命的是在多线程不能正常工作。</p>
<p>　　<em>线程安全</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Thread Safe</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </div><div class="line">    <span class="keyword">private</span> <span class="title">Singleton</span> (){}</div><div class="line">      </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span>() {  </div><div class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {  </div><div class="line">            instance = <span class="keyword">new</span> Singleton();  </div><div class="line">        }  </div><div class="line">    <span class="keyword">return</span> instance;  </div><div class="line">    }  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　这种写法能够在多线程中很好的工作，而且看起来它也具备很好的<code>lazy loading</code>，但是，遗憾的是，效率很低，99%情况下不需要同步。</p>
<h3 id="饿汉方式">饿汉方式</h3>
<p>　　<strong>饿汉方式</strong>，指全局的单例实例在类装载时构建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </div><div class="line">    <span class="keyword">private</span> <span class="title">Singleton</span> (){}  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>() {  </div><div class="line">    <span class="keyword">return</span> instance;  </div><div class="line">    }  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　这种方式基于<code>classloder</code>机制避免了多线程的同步问题，不过，<code>instance</code>在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用<code>getInstance</code>方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化<code>instance</code>显然没有达到<code>lazy loading</code>的效果。</p>
<h3 id="静态内部类">静态内部类</h3>
<p>　　因为单例是静态的<code>final</code>变量，当类第一次加载到内存中的时候就初始化了，其<code>thread-safe</code>性由 JVM 来负责保证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>{  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </div><div class="line">    }  </div><div class="line">    <span class="keyword">private</span> <span class="title">Singleton</span> (){}  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span>() {  </div><div class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </div><div class="line">    }  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　首先，其他类在引用这个<code>Singleton</code>的类时，只是新建了一个引用，并没有开辟一个的堆空间存放（对象所在的内存空间）。接着，当使用<code>Singleton.getInstance()</code>方法后，Java虚拟机（JVM）会加载<code>SingletonHolder.class</code>（JLS规定每个class对象只能被初始化一次），并实例化一个<code>Singleton</code>对象。这种方式的缺点是需要在Java的另外一个内存空间（Java PermGen 永久代内存，这块内存是虚拟机加载class文件存放的位置）占用一个大块的空间。</p>
<h3 id="枚举">枚举</h3>
<p>　　枚举单例（Enum Singleton）是实现单例模式的一种新方式，枚举这个特性是在Java5才出现的。《Effective Java》一书中有介绍这个特性，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton {  </div><div class="line">    INSTANCE;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span>() {  </div><div class="line">    }  </div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　默认枚举实例的创建是线程安全的，但是在枚举中的其他任何方法由程序员自己负责。如果你正在使用实例方法，那么你需要确保线程安全（如果它影响到其他对象的状态的话）。传统单例存在的另外一个问题是一旦你实现了序列化接口，那么它们不再保持单例了，但是枚举单例，JVM对序列化有保证。枚举实现单例的好处：有序列化和线程安全的保证，代码简单。</p>
<h3 id="双重校验锁">双重校验锁</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton singleton = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> <span class="title">Singleton</span>(){}</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>(){</div><div class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>){ </div><div class="line">           synchronize (Singleton.class){</div><div class="line">               <span class="keyword">if</span>( singleton == <span class="keyword">null</span> ) { <span class="comment">// double check </span></div><div class="line">                   singleton = <span class="keyword">new</span> Singleton();</div><div class="line">               }</div><div class="line">        }</div><div class="line">        <span class="keyword">return</span> singleton;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　当两个线程执行完第一个 <code>singleton == null</code> 后等待锁， 其中一个线程获得锁并进入<code>synchronize</code>后，实例化了，然后退出释放锁，另外一个线程获得锁，进入又想实例化，会判断是否进行实例化了，如果存在，就不进行实例化了。</p>
<h2 id="Conclusion">Conclusion</h2>
<p>　　单例模式有五种写法：懒汉、饿汉、静态内部类、枚举、双重检验锁。一般来说，推荐使用饿汉和静态内部类两种方式。<br>　　Singleton 是最简单也最被滥用的模式。和其他设计模式一样，需要不断的实践经验的积累。对于 Beginner 来说了解一些基本的概念和模式即可，不要刻意追求设计模式。不断地看优秀的代码，努力写出高可阅读性代码才是王道。</p>
<p><strong>References</strong></p>
<ul>
<li><a href="http://blog.javachen.com/2013/06/09/note-about-java-singleton-model/#" target="_blank" rel="external">Java笔记：单例模式</a></li>
<li><a href="http://cantellow.iteye.com/blog/838473" target="_blank" rel="external">单例模式的七种写法</a></li>
<li><a href="http://www.cnblogs.com/codeguy/p/3580486.html" target="_blank" rel="external">JAVA中单例模式的几种实现方式</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="单例模式介绍">单例模式介绍</h2>
<p>　　单例模式最初的定义出现于《设计模式》（艾迪生维斯理, 1994）：</p>
<blockquote>
<p><em>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</em></p>
</blockquote]]>
    </summary>
    
      <category term="Java" scheme="http://chenqx.github.com/tags/Java/"/>
    
      <category term="Design Pattern" scheme="http://chenqx.github.com/tags/Design-Pattern/"/>
    
      <category term="Java" scheme="http://chenqx.github.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[递归算法详解]]></title>
    <link href="http://chenqx.github.com/2014/09/29/Algorithm-Recursive-Programming/"/>
    <id>http://chenqx.github.com/2014/09/29/Algorithm-Recursive-Programming/</id>
    <published>2014-09-29T02:31:58.000Z</published>
    <updated>2014-11-15T10:27:04.000Z</updated>
    <content type="html"><![CDATA[<p>　　计算机科学的新学生通常难以理解递归程序设计的概念。递归思想之所以困难，原因在于它非常像是循环推理（<code>circular reasoning</code>）。它也不是一个直观的过程；当我们指挥别人做事的时候，我们极少会递归地指挥他们。</p>
<h2 id="Introduction">Introduction</h2>
<p>　　递归算法是一种直接或者间接调用自身函数或者方法的算法。递归算法的实质是把问题分解成规模缩小的同类问题的子问题，然后递归调用方法来表示问题的解。递归算法对解决一大类问题很有效，它可以使算法简洁和易于理解。递归算法，其实说白了，就是程序的自身调用。它表现在一段程序中往往会遇到调用自身的那样一种coding策略，这样我们就可以利用大道至简的思想，把一个大的复杂的问题层层转换为一个小的和原问题相似的问题来求解的这样一种策略。递归往往能给我们带来非常简洁非常直观的代码形势，从而使我们的编码大大简化，然而递归的思维确实很我们的常规思维相逆的，我们通常都是从上而下的思维问题， 而递归趋势从下往上的进行思维。这样我们就能看到我们会用很少的语句解决了非常大的问题，所以递归策略的最主要体现就是小的代码量解决了非常复杂的问题。<br>　　递归算法解决问题的特点：</p>
<ul>
<li>递归就是方法里调用自身。</li>
<li>在使用递增归策略时，必须有一个明确的递归结束条件，称为递归出口。</li>
<li>递归算法解题通常显得很简洁，但递归算法解题的运行效率较低。所以一般不提倡用递归算法设计程序。</li>
<li>在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等，所以一般不提倡用递归算法设计程序。</li>
</ul>
<p>　　递归算法要求。递归算法所体现的“重复”一般有三个要求：</p>
<p>　　(1) 是每次调用在规模上都有所缩小（通常是减半）；<br>　　(2) 是相邻两次重复之间有紧密的联系，前一次要为后一次做准备（通常前一次的输出就作为后一次的输入）；<br>　　(3) 是在问题的规模极小时必须用直接给出解答而不再进行递归调用，因而每次递归调用都是有条件的(以规模未达到直接解答的大小为条件)，无条件递归调用将会成为死循环而不能正常结束。</p>
<h2 id="从递归的经典示例开始">从递归的经典示例开始</h2>
<h3 id="计算阶乘">计算阶乘</h3>
<p>　　计算阶乘是递归程序设计的一个经典示例。计算某个数的阶乘就是用那个数去乘包括 1 在内的所有比它小的数。例如，<code>factorial(5)</code> 等价于 <code>5*4*3*2*1</code>，而 <code>factorial(3)</code> 等价于 <code>3*2*1</code>。<br>　　阶乘的一个有趣特性是，某个数的阶乘等于起始数（starting number）乘以比它小一的数的阶乘。例如，<code>factorial(5)</code> 与 <code>5 * factorial(4)</code> 相同。您很可能会像这样编写阶乘函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> factorial(<span class="keyword">int</span> n){</div><div class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>(<em>注：本文的程序示例用C语言编写</em>)<br>　　不过，这个函数的问题是，它会永远运行下去，因为它没有终止的地方。函数会连续不断地调用 <code>factorial</code>。 当计算到零时，没有条件来停止它，所以它会继续调用零和负数的阶乘。因此，我们的函数需要一个条件，告诉它何时停止。<br>　　由于小于 1 的数的阶乘没有任何意义，所以我们在计算到数字 1 的时候停止，并返回 1 的阶乘（即 1）。因此，真正的递归函数类似于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> factorial(<span class="keyword">int</span> n){</div><div class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">else</span></div><div class="line">      <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　可见，只要初始值大于零，这个函数就能够终止。停止的位置称为 基线条件（base case）。基线条件是递归程序的 最底层位置，在此位置时没有必要再进行操作，可以直接返回一个结果。所有递归程序都必须至少拥有一个基线条件，而且 必须确保它们最终会达到某个基线条件；否则，程序将永远运行下去，直到程序缺少内存或者栈空间。</p>
<h3 id="斐波纳契数列">斐波纳契数列</h3>
<p>　　<a href="http://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97" target="_blank" rel="external">斐波纳契数列</a>(Fibonacci Sequence)，最开始用于描述兔子生长的数目时用上了这数列。从数学上，费波那契数列是以递归的方法来定义：<br><img src="http://newtonblogimg.qiniudn.com/Fibonacci%20Sequence.png" alt=""><br>　　这样斐波纳契数列的递归程序就可以非常清晰的写出来了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> Fibonacci(<span class="keyword">int</span> n){</div><div class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)  </div><div class="line">        <span class="keyword">return</span> n;  </div><div class="line">    <span class="keyword">else</span>  </div><div class="line">        <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>) + Fibonacci(n-<span class="number">2</span>);  </div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="递归程序的基本步骤">递归程序的基本步骤</h2>
<p>　　每一个递归程序都遵循相同的基本步骤：</p>
<pre><code>(<span class="number">1</span>) 初始化算法。递归程序通常需要一个开始时使用的种子值（seed <span class="keyword">value</span>）。要完成此任务，可以向函数传递参数，或者提供一个入口函数， 这个函数是非递归的，但可以为递归计算设置种子值。
(<span class="number">2</span>) 检查要处理的当前值是否已经与基线条件相匹配。如果匹配，则进行处理并返回值。
(<span class="number">3</span>) 使用更小的或更简单的子问题（或多个子问题）来重新定义答案。
(<span class="number">4</span>) 对子问题运行算法。
(<span class="number">5</span>) 将结果合并入答案的表达式。
(<span class="number">6</span>) 返回结果。
</code></pre><h2 id="使用归纳定义">使用归纳定义</h2>
<p>　　有时候，编写递归程序时难以获得更简单的子问题。 不过，使用 归纳定义的（<code>inductively-defined</code>）数据集 可以令子问题的获得更为简单。归纳定义的数据集是根据自身定义的数据结构 —— 这叫做 <em>归纳定义</em>（<code>inductive definition</code>）。<br>　　例如，链表就是根据其本身定义出来的。链表所包含的节点结构体由两部分构成：它所持有的数据，以及指向另一个节点结构体（或者是 NULL，结束链表）的指针。 由于节点结构体内部包含有一个指向节点结构体的指针，所以称之为是归纳定义的。<br>　　使用归纳数据编写递归过程非常简单。注意，与我们的递归程序非常类似，链表的定义也包括一个基线条件 —— 在这里是 NULL 指针。 由于 NULL 指针会结束一个链表，所以我们也可以使用 NULL 指针条件作为基于链表的很多递归程序的基线条件。<br>　　下面看两个例子。</p>
<h3 id="链表求和示例">链表求和示例</h3>
<p>　　让我们来看一些基于链表的递归函数示例。假定我们有一个数字列表，并且要将它们加起来。履行递归过程序列的每一个步骤，以确定它如何应用于我们的求和函数：</p>
<pre><code>(<span class="number">1</span>) 初始化算法。这个算法的种子值是要处理的第一个节点，将它作为参数传递给函数。
(<span class="number">2</span>) 检查基线条件。程序需要检查确认当前节点是否为 <span class="keyword">NULL</span> 列表。如果是，则返回零，因为一个空列表的所有成员的和为零。
(<span class="number">3</span>) 使用更简单的子问题重新定义答案。我们可以将答案定义为当前节点的内容加上列表中其余部分的和。为了确定列表其余部分的和， 我们针对下一个节点来调用这个函数。
(<span class="number">4</span>) 合并结果。递归调用之后，我们将当前节点的值加到递归调用的结果上。
</code></pre><p>　　这样我们就可以很简单的写出链表求和的递归程序，实例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sum_list(<span class="keyword">struct</span> list_node *l){</div><div class="line">    <span class="keyword">if</span>(l == NULL)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> l.data + sum_list(l.next);</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="汉诺塔问题">汉诺塔问题</h3>
<p>　　汉诺塔（Hanoi Tower）问题也是一个经典的递归问题，该问题描述如下：</p>
<pre><code>汉诺塔问题：古代有一个梵塔，塔内有三个座<span class="literal">A</span>、B、C，<span class="literal">A</span>座上有<span class="number">64</span>个盘子，盘子大小不等，大的在下，小的在上（如图）。有一个和尚想把这<span class="number">64</span>个盘子从<span class="literal">A</span>座移到B座，但每次只能允许移动一个盘子，并且在移动过程中，<span class="number">3</span>个座上的盘子始终保持大盘在下，小盘在上。
</code></pre><p>　　<img src="http://newtonblogimg.qiniudn.com/Hanoi%20Tower%20Solving.png" alt="Hanoi Tower Solving"></p>
<ul>
<li>如果只有 1 个盘子，则不需要利用B塔，直接将盘子从A移动到C。</li>
<li>如果有 2 个盘子，可以先将盘子1上的盘子2移动到B；将盘子1移动到C；将盘子2移动到C。这说明了：可以借助B将2个盘子从A移动到C，当然，也可以借助C将2个盘子从A移动到B。</li>
<li>如果有3个盘子，那么根据2个盘子的结论，可以借助c将盘子1上的两个盘子从A移动到B；将盘子1从A移动到C，A变成空座；借助A座，将B上的两个盘子移动到C。<br>　　以此类推，上述的思路可以一直扩展到 n 个盘子的情况，将将较小的 n-1个盘子看做一个整体，也就是我们要求的子问题，以借助B塔为例，可以借助空塔B将盘子A上面的 n-1 个盘子从A移动到B；将A最大的盘子移动到C，A变成空塔；借助空塔A，将B塔上的 n-2 个盘子移动到A，将C最大的盘子移动到C，B变成空塔…<br>　　根据以上的分析，不难写出程序：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Hanoi (<span class="keyword">int</span> n, <span class="keyword">char</span> A, <span class="keyword">char</span> B, <span class="keyword">char</span> C){</div><div class="line">    <span class="keyword">if</span> (n==<span class="number">1</span>){ <span class="comment">//end condition</span></div><div class="line">        move(A,B);<span class="comment">//‘move’ can be defined to be a print function</span></div><div class="line">    }</div><div class="line">    <span class="keyword">else</span>{</div><div class="line">        Hanoi(n-<span class="number">1</span>,A,C,B);<span class="comment">//move sub [n-1] pans from A to B</span></div><div class="line">        move(A,C);<span class="comment">//move the bottom(max) pan to C</span></div><div class="line">        Hanoi(n-<span class="number">1</span>,B,A,C);<span class="comment">//move sub [n-1] pans from B to C</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h1 id="将循环转化为递归">将循环转化为递归</h1>
<p>　　在下表中了解循环的特性，看它们可以如何与递归函数的特性相对比。</p>
<table>
<thead>
<tr>
<th><strong>Properties</strong></th>
<th><strong>Loops</strong></th>
<th><strong>Recursive functions</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>重复</td>
<td>为了获得结果，反复执行同一代码块；以完成代码块或者执行 continue 命令信号而实现重复执行。</td>
<td>为了获得结果，反复执行同一代码块；以反复调用自己为信号而实现重复执行。</td>
</tr>
<tr>
<td>终止条件</td>
<td>为了确保能够终止，循环必须要有一个或多个能够使其终止的条件，而且必须保证它能在某种情况下满足这些条件的其中之一。</td>
<td>为了确保能够终止，递归函数需要有一个基线条件，令函数停止递归。</td>
</tr>
<tr>
<td>状态</td>
<td>循环进行时更新当前状态。</td>
<td>当前状态作为参数传递。</td>
</tr>
</tbody>
</table>
<p>　　可见，递归函数与循环有很多类似之处。实际上，可以认为循环和递归函数是能够相互转换的。 区别在于，使用递归函数极少被迫修改任何一个变量 —— 只需要将新值作为参数传递给下一次函数调用。 这就使得您可以获得避免使用可更新变量的所有益处，同时能够进行重复的、有状态的行为。<br>　　下面还是以阶乘为例子，循环写法为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> factorial(<span class="keyword">int</span> n){</div><div class="line">    <span class="keyword">int</span> product = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>){</div><div class="line">        product *= n;</div><div class="line">        n--;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> product;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　递归写法在第二节中已经介绍过了，这里就不重复了，可以比较一下。</p>
<h1 id="尾递归介绍">尾递归介绍</h1>
<p>　　对于递归函数的使用，人们所关心的一个问题是栈空间的增长。确实，随着被调用次数的增加，某些种类的递归函数会线性地增加栈空间的使用 —— 不过，有一类函数，即尾部递归函数，不管递归有多深，栈的大小都保持不变。尾递归属于线性递归，更准确的说是线性递归的子集。<br>　　函数所做的最后一件事情是一个函数调用（递归的或者非递归的），这被称为 尾部调用（<code>tail-call</code>）。使用尾部调用的递归称为 <em>尾部递归</em>。当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。<br>　　让我们来看一些尾部调用和非尾部调用函数示例，以了解尾部调用的含义到底是什么：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> test1(){</div><div class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</div><div class="line">    test1(); <span class="comment">/* recursive, but not a tail call.  We continue */</span></div><div class="line">             <span class="comment">/* processing in the function after it returns. */</span></div><div class="line">    a = a + <span class="number">4</span>;</div><div class="line">    <span class="keyword">return</span> a;</div><div class="line">}</div><div class="line"><span class="keyword">int</span> test2(){</div><div class="line">    <span class="keyword">int</span> q = <span class="number">4</span>;</div><div class="line">    q = q + <span class="number">5</span>;</div><div class="line">    <span class="keyword">return</span> q + test1(); <span class="comment">/* test1() is not in tail position.</span></div><div class="line">                         * There is still more work to be</div><div class="line">                         * done after test1() returns (like</div><div class="line">                         * adding q to the result*/</div><div class="line">}</div><div class="line"><span class="keyword">int</span> test3(){</div><div class="line">    <span class="keyword">int</span> b = <span class="number">5</span>;</div><div class="line">    b = b + <span class="number">2</span>;</div><div class="line">    <span class="keyword">return</span> test1();  <span class="comment">/* This is a tail-call.  The return value</span></div><div class="line">                      * of test1() is used as the return value</div><div class="line">                      * for this function.*/                    </div><div class="line">}</div><div class="line"><span class="keyword">int</span> test4(){</div><div class="line">    test3(); <span class="comment">/* not in tail position */</span></div><div class="line">    test3(); <span class="comment">/* not in tail position */</span></div><div class="line">    <span class="keyword">return</span> test3(); <span class="comment">/* in tail position */</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　可见，要使调用成为真正的尾部调用，在尾部调用函数返回之前，对其结果 <em>不能执行任何其他操作</em>。<br><em>注意</em>，由于在函数中不再做任何事情，那个函数的实际的栈结构也就不需要了。惟一的问题是，很多程序设计语言和编译器不知道 如何除去没有用的栈结构。如果我们能找到一个除去这些不需要的栈结构的方法，那么我们的尾部递归函数就可以在固定大小的栈中运行。<br>　　在尾部调用之后除去栈结构的方法称为 <em>尾部调用优化</em> 。<br>　　那么这种优化是什么？我们可以通过询问其他问题来回答那个问题：</p>
<pre><code>(1) 函数在尾部被调用之后，还需要使用哪个本地变量？哪个也不需要。
(2) 会对返回的值进行什么处理？什么处理也没有。
(3) 传递到函数的哪个参数将会被使用？哪个都没有。
</code></pre><p>　　好像一旦控制权传递给了尾部调用的函数，栈中就再也没有有用的内容了。虽然还占据着空间，但函数的栈结构此时实际上已经没有用了，因此，尾部调用优化就是要在尾部进行函数调用时使用下一个栈结构 <em>覆盖</em> 当前的栈结构，同时保持原来的返回地址。<br>　　我们所做的本质上是对栈进行处理。再也不需要活动记录（<code>activation record</code>），所以我们将删掉它，并将尾部调用的函数重定向返回到调用我们的函数。 这意味着我们必须手工重新编写栈来仿造一个返回地址，以使得尾部调用的函数能直接返回到调用它的函数。
　　</p>
<h1 id="Conclusion">Conclusion</h1>
<p>　　递归是一门伟大的艺术，使得程序的正确性更容易确认，而不需要牺牲性能，但这需要程序员以一种新的眼光来研究程序设计。对新程序员 来说，命令式程序设计通常是一个更为自然和直观的起点，这就是为什么大部分程序设计说明都集中关注命令式语言和方法的原因。 不过，随着程序越来越复杂，递归程序设计能够让程序员以可维护且逻辑一致的方式更好地组织代码。</p>
<p><strong>References</strong></p>
<ul>
<li><a href="http://www.ibm.com/developerworks/linux/library/l-recurs/index.html" target="_blank" rel="external">Mastering recursive programming</a></li>
<li><a href="http://blog.csdn.net/wangjinyu501/article/details/8248492" target="_blank" rel="external">递归算法</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　计算机科学的新学生通常难以理解递归程序设计的概念。递归思想之所以困难，原因在于它非常像是循环推理（<code>circular reasoning</code>）。它也不是一个直观的过程；当我们指挥别人做事的时候，我们极少会递归地指挥他们。</p>
<h2 id="In]]>
    </summary>
    
      <category term="Algorithm" scheme="http://chenqx.github.com/tags/Algorithm/"/>
    
      <category term="C/C++" scheme="http://chenqx.github.com/tags/C-C/"/>
    
      <category term="Algorithm" scheme="http://chenqx.github.com/categories/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C/C++内存管理详解]]></title>
    <link href="http://chenqx.github.com/2014/09/25/Cpp-Memory-Management/"/>
    <id>http://chenqx.github.com/2014/09/25/Cpp-Memory-Management/</id>
    <published>2014-09-25T02:31:59.000Z</published>
    <updated>2014-11-11T15:01:24.000Z</updated>
    <content type="html"><![CDATA[<p>　　内存管理是C++最令人切齿痛恨的问题，也是C++最有争议的问题，C++高手从中获得了更好的性能，更大的自由，C++菜鸟的收获则是一遍一遍的检查代码和对C++的痛恨，但内存管理在C++中无处不在，内存泄漏几乎在每个C++程序中都会发生，因此要想成为C++高手，内存管理一关是必须要过的，除非放弃C++，转到Java或者.NET，他们的内存管理基本是自动的，当然你也放弃了自由和对内存的支配权，还放弃了C++超绝的性能。<br>　　伟大的Bill Gates 曾经失言：</p>
<blockquote>
<p>　<em>640K ought to be enough for everybody</em> — Bill Gates 1981</p>
</blockquote>
<p>　　程序员们经常编写内存管理程序，往往提心吊胆。如果不想触雷，唯一的解决办法就是发现所有潜伏的地雷并且排除它们，躲是躲不了的。</p>
<h2 id="内存分配方式">内存分配方式</h2>
<h3 id="简介">简介</h3>
<p>　　在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。<br>　　<strong>栈</strong>：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。<br>　　<strong>堆</strong>：就是那些由 <code>new</code>分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个<code>new</code>就要对应一个 <code>delete</code>。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。<br>　　<strong>自由存储区</strong>：就是那些由<code>malloc</code>等分配的内存块，他和堆是十分相似的，不过它是用<code>free</code>来结束自己的生命的。<br>　　<strong>全局/静态存储区</strong>：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。<br>　　<strong>常量存储区</strong>：这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。</p>
<h3 id="明确区分堆与栈">明确区分堆与栈</h3>
<p>　　堆与栈的区分问题，似乎是一个永恒的话题，由此可见，初学者对此往往是混淆不清的，所以我决定拿他第一个开刀。<br>　　首先，我们举一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> f() { <span class="keyword">int</span>* p=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; }</div></pre></td></tr></table></figure>

<p>　　这条短短的一句话就包含了堆与栈，看到<code>new</code>，我们首先就应该想到，我们分配了一块堆内存，那么指针<code>p</code>呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针<code>p</code>。在程序会先确定在堆中分配内存的大小，然后调用<code>operator new</code>分配内存，然后返回这块内存的首地址，放入栈中，他在VC6下的汇编代码如下：</p>
<pre><code><span class="number">00401028</span> <span class="keyword">push</span> <span class="number">14h</span>
0040102A <span class="keyword">call</span> operator new (<span class="number">00401060</span>)
0040102F <span class="keyword">add</span> <span class="literal">esp</span>,<span class="number">4</span>
<span class="number">00401032</span> <span class="keyword">mov</span> <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">8</span>],<span class="number">eax</span>
<span class="number">00401035</span> <span class="keyword">mov</span> <span class="number">eax</span>,<span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">8</span>]
<span class="number">00401038</span> <span class="keyword">mov</span> <span class="preprocessor">dword</span> <span class="preprocessor">ptr</span> [<span class="literal">ebp</span>-<span class="number">4</span>],<span class="number">eax</span>
</code></pre><p>　　这里，我们为了简单并没有释放内存，那么该怎么去释放呢？是<code>delete p</code>么？澳，错了，应该是<code>delete []p</code>，这是为了告诉编译器：我删除的是一个数组，编译器就会根据相应的<code>Cookie</code>信息去进行释放内存的工作。</p>
<h3 id="堆和栈究竟有什么区别">堆和栈究竟有什么区别</h3>
<p>　　好了，我们回到我们的主题：堆和栈究竟有什么区别？<br>　　主要的区别由以下几点：<br>　　(1). 管理方式不同<br>　　(2). 空间大小不同<br>　　(3). 能否产生碎片不同<br>　　(4). 生长方向不同<br>　　(5). 分配方式不同<br>　　(6). 分配效率不同<br>　　管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生<code>memory leak</code>。<br>　　空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：<br>　　打开工程，依次操作菜单如下<code>：Project-&gt;Setting-&gt;Link</code>，在<code>Category</code> 中选中<code>Output</code>，然后在<code>Reserve</code>中设定堆栈的最大值和<code>commit</code>。<br>　　注意：reserve最小值为4Byte；<code>commit</code>是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。<br>　　碎片问题：对于堆来讲，频繁的<code>new/delete</code>势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。<br>　　生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。<br>　　分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由<code>alloca</code>函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。<br>　　分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。<br>　　从这里我们可以看到，堆和栈相比，由于大量<code>new/delete</code>的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。<br>　　虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。<br>　　无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果,就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候<code>debug</code>可是相当困难的：）</p>
<h2 id="控制C++的内存分配">控制C++的内存分配</h2>
<p>　　在嵌入式系统中使用C++的一个常见问题是内存分配，即对<code>new</code> 和 <code>delete</code> 操作符的失控。<br>　　具有讽刺意味的是，问题的根源却是C++对内存的管理非常的容易而且安全。具体地说，当一个对象被消除时，它的析构函数能够安全的释放所分配的内存。<br>　　这当然是个好事情，但是这种使用的简单性使得程序员们过度使用<code>new</code> 和 <code>delete</code>，而不注意在嵌入式C++环境中的因果关系。并且，在嵌入式系统中，由于内存的限制，频繁的动态分配不定大小的内存会引起很大的问题以及堆破碎的风险。<br>　　作为忠告，保守的使用内存分配是嵌入式环境中的第一原则。<br>　　但当你必须要使用<code>new</code>和<code>delete</code>时，你不得不控制C++中的内存分配。你需要用一个全局的<code>new</code> 和<code>delete</code>来代替系统的内存分配符，并且一个类一个类的重载<code>new</code>和<code>delete</code>。<br>　　一个防止堆破碎的通用方法是从不同固定大小的内存持中分配不同类型的对象。对每个类重载<code>new</code> 和<code>delete</code>就提供了这样的控制。</p>
<h3 id="重载全局的new和delete操作符">重载全局的new和delete操作符</h3>
<p>　　可以很容易地重载new 和 delete 操作符，如下所示:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>(size_t size){</div><div class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size);</div><div class="line">    <span class="keyword">return</span> (p);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">void</span> *p){</div><div class="line">    <span class="built_in">free</span>(p);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　这段代码可以代替默认的操作符来满足内存分配的请求。出于解释C++的目的，我们也可以直接调用<code>malloc()</code> 和<code>free()</code>。<br>　　也可以对单个类的<code>new</code> 和 <code>delete</code>操作符重载。这是你能灵活的控制对象的内存分配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> TestClass {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>(size_t size);</div><div class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">void</span> *p);</div><div class="line">    <span class="comment">// .. other members here ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">void</span> *TestClass::<span class="keyword">operator</span> <span class="keyword">new</span>(size_t size){</div><div class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size); <span class="comment">// Replace this with alternative allocator</span></div><div class="line">    <span class="keyword">return</span> (p);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> TestClass::<span class="keyword">operator</span> <span class="keyword">delete</span>(<span class="keyword">void</span> *p){</div><div class="line">    <span class="built_in">free</span>(p); <span class="comment">// Replace this with alternative de-allocator</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　所有<code>TestClass</code> 对象的内存分配都采用这段代码。更进一步，任何从<code>TestClass</code> 继承的类也都采用这一方式，除非它自己也重载了<code>new</code> 和 <code>delete</code> 操作符。通过重载<code>new</code> 和 <code>delete</code> 操作符的方法，你可以自由地采用不同的分配策略，从不同的内存池中分配不同的类对象。</p>
<h3 id="为单个的类重载new[]和delete[]">为单个的类重载new[]和delete[]</h3>
<p>　　必须小心对象数组的分配。你可能希望调用到被你重载过的<code>new</code> 和 <code>delete</code> 操作符，但并不如此。内存的请求被定向到全局的<code>new[]</code>和<code>delete[]</code> 操作符，而这些内存来自于系统堆。<br>　　C++将对象数组的内存分配作为一个单独的操作，而不同于单个对象的内存分配。为了改变这种方式，你同样需要重载<code>new[]</code> 和 <code>delete[]</code>操作符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> TestClass {</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[ ](size_t size);</div><div class="line">    <span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[ ](<span class="keyword">void</span> *p);</div><div class="line">    <span class="comment">// .. other members here ..</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">void</span> *TestClass::<span class="keyword">operator</span> <span class="keyword">new</span>[ ](size_t size){</div><div class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size);</div><div class="line">    <span class="keyword">return</span> (p);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> TestClass::<span class="keyword">operator</span> <span class="keyword">delete</span>[ ](<span class="keyword">void</span> *p){</div><div class="line">    <span class="built_in">free</span>(p);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>){</div><div class="line">    TestClass *p = <span class="keyword">new</span> TestClass[<span class="number">10</span>];</div><div class="line">    <span class="comment">// ... etc ...</span></div><div class="line">    <span class="keyword">delete</span>[ ] p;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　但是<strong>注意</strong>：对于多数C++的实现，<code>new[]</code>操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。在你的内存分配机制重要考虑的这一点。你应该尽量避免分配对象数组，从而使你的内存分配策略简单。</p>
<h2 id="常见的内存错误及其对策">常见的内存错误及其对策</h2>
<p>　　发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。有时用户怒气冲冲地把你找来，程序却没有发生任何问题，你一走，错误又发作了。 常见的内存错误及其对策如下：</p>
<ul>
<li>内存分配未成功，却使用了它。编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为<code>NULL</code>。如果指针<code>p</code>是函数的参数，那么在函数的入口处用<code>assert(p!=NULL)</code>进行检查。如果是用<code>malloc</code>或<code>new</code>来申请内存，应该用<code>if(p==NULL)</code> 或<code>if(p!=NULL)</code>进行防错处理。</li>
<li>内存分配虽然成功，但是尚未初始化就引用它。犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。</li>
<li>内存分配成功并且已经初始化，但操作越过了内存的边界。例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在<code>for</code>循环语句中，循环次数很容易搞错，导致数组操作越界。</li>
<li>忘记了释放内存，造成内存泄露。含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。动态内存的申请与释放必须配对，程序中<code>malloc</code>与<code>free</code>的使用次数一定要相同，否则肯定有错误（<code>new/delete</code>同理）。</li>
<li>释放了内存却继续使用它。</li>
</ul>
<p>　　有三种情况：<br>　　(1). 程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。<br>　　(2). 函数的<code>return</code>语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。<br>　　(3). 使用<code>free</code>或<code>delete</code>释放了内存后，没有将指针设置为<code>NULL</code>。<strong>导致产生“野指针”</strong>。<br>　　<strong>那么如何避免产生野指针呢</strong>？这里列出了5条规则，平常写程序时多注意一下，养成良好的习惯。</p>
<blockquote>
<p>规则1：用<code>malloc</code>或<code>new</code>申请内存之后，应该立即检查指针值是否为<code>NULL</code>。防止使用指针值为<code>NULL</code>的内存。<br>规则2：不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。<br>规则3：避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。<br>规则4：动态内存的申请与释放必须配对，防止内存泄漏。<br>规则5：用<code>free</code>或<code>delete</code>释放了内存之后，立即将指针设置为<code>NULL</code>，防止产生“野指针”。</p>
</blockquote>
<h2 id="针与数组的对比">针与数组的对比</h2>
<p>　　C++/C程序中，指针和数组在不少地方可以相互替换着用，让人产生一种错觉，以为两者是等价的。<br>　　数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。<br>　　指针可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。<br>　　下面以字符串为例比较指针与数组的特性。</p>
<h3 id="修改内容">修改内容</h3>
<p>　　下面示例中，字符数组a的容量是6个字符，其内容为 hello。a的内容可以改变，如<code>a[0]= ‘X’</code>。指针p指向常量字符串“world”（位于静态存储区，内容为world），常量字符串的内容是不可以被修改的。从语法上看，编译器并不觉得语句<code>p[0]= ‘X’</code>有什么不妥，但是该语句企图修改常量字符串的内容而导致运行错误。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> a[] = “hello”;</div><div class="line">a[<span class="number">0</span>] = ‘X’;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; endl;</div><div class="line"><span class="keyword">char</span> *p = “world”; <span class="comment">// 注意p指向常量字符串</span></div><div class="line">p[<span class="number">0</span>] = ‘X’; <span class="comment">// 编译器不能发现该错误</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; p &lt;&lt; endl;</div></pre></td></tr></table></figure>

<h3 id="内容复制与比较">内容复制与比较</h3>
<p>　　不能对数组名进行直接复制与比较。若想把数组a的内容复制给数组b，不能用语句 <code>b = a</code> ，否则将产生编译错误。应该用标准库函数<code>strcpy</code>进行复制。同理，比较b和a的内容是否相同，不能用<code>if(b==a)</code> 来判断，应该用标准库函数<code>strcmp</code>进行比较。<br>　　语句 <code>p = a</code> 并不能把a的内容复制指针p，而是把a的地址赋给了p。要想复制a的内容，可以先用库函数<code>malloc</code>为p申请一块容量为<code>strlen(a)+1</code>个字符的内存，再用<code>strcpy</code>进行字符串复制。同理，语句<code>if(p==a)</code> 比较的不是内容而是地址，应该用库函数<code>strcmp</code>来比较。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数组…</span></div><div class="line"><span class="keyword">char</span> a[] = <span class="string">"hello"</span>;</div><div class="line"><span class="keyword">char</span> b[<span class="number">10</span>];</div><div class="line"><span class="built_in">strcpy</span>(b, a); <span class="comment">// 不能用 b = a;</span></div><div class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(b, a) == <span class="number">0</span>) <span class="comment">// 不能用 if (b == a)</span></div><div class="line">…</div><div class="line"></div><div class="line"><span class="comment">// 指针…</span></div><div class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(a);</div><div class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*(len+<span class="number">1</span>));</div><div class="line"><span class="built_in">strcpy</span>(p,a); <span class="comment">// 不要用 p = a;</span></div><div class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(p, a) == <span class="number">0</span>) <span class="comment">// 不要用 if (p == a)</span></div><div class="line">…</div></pre></td></tr></table></figure>

<h3 id="计算内存容量">计算内存容量</h3>
<p>　　用运算符<code>sizeof</code>可以计算出数组的容量（字节数）。如下示例中，<code>sizeof(a)</code>的值是12（注意别忘了’’）。指针p指向a，但是<code>sizeof(p)</code>的值却是4。这是因为<code>sizeof(p)</code>得到的是一个指针变量的字节数，相当于<code>sizeof(char*)</code>，而不是p所指的内存容量。C++/C语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> a[] = <span class="string">"hello world"</span>;</div><div class="line"><span class="keyword">char</span> *p = a;</div><div class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; endl; <span class="comment">// 12字节</span></div><div class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; endl; <span class="comment">// 4字节</span></div></pre></td></tr></table></figure>

<p>　　注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。如下示例中，不论数组a的容量是多少，<code>sizeof(a)</code>始终等于<code>sizeof(char *)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Func(<span class="keyword">char</span> a[<span class="number">100</span>]){</div><div class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; endl; <span class="comment">// 4字节而不是100字节</span></div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="指针参数是如何传递内存的">指针参数是如何传递内存的</h2>
<p>　　如果函数的参数是一个指针，不要指望用该指针去申请动态内存。如下示例中，Test函数的语句<code>GetMemory(str, 200)</code>并没有使<code>str</code>获得期望的内存，<code>str</code>依旧是<code>NULL</code>，为什么？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> GetMemory(<span class="keyword">char</span> *p, <span class="keyword">int</span> num){</div><div class="line">    p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Test(<span class="keyword">void</span>){</div><div class="line">    <span class="keyword">char</span> *str = NULL;</div><div class="line">    GetMemory(str, <span class="number">100</span>); <span class="comment">// str 仍然为 NULL</span></div><div class="line"></div><div class="line">    <span class="built_in">strcpy</span>(str, <span class="string">"hello"</span>); <span class="comment">// 运行错误</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　毛病出在函数<code>GetMemory</code>中。编译器总是要为函数的每个参数制作临时副本，指针参数p的副本是 <code>_p</code>，编译器使 <code>_p=p</code>。如果函数体内的程序修改了<code>_p</code>的内容，就导致参数p的内容作相应的修改。这就是指针可以用作输出参数的原因。在本例中，<code>_p</code>申请了新的内存，只是把 <code>_p</code>所指的内存地址改变了，但是p丝毫未变。所以函数<code>GetMemory</code>并不能输出任何东西。事实上，每执行一次<code>GetMemory</code>就会泄露一块内存，因为没有用<code>free</code>释放内存。<br>　　如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”，见示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> GetMemory2(<span class="keyword">char</span> **p, <span class="keyword">int</span> num){</div><div class="line">    *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Test2(<span class="keyword">void</span>){</div><div class="line">    <span class="keyword">char</span> *str = NULL;</div><div class="line">    GetMemory2(&str, <span class="number">100</span>); <span class="comment">// 注意参数是 &str，而不是str</span></div><div class="line">    <span class="built_in">strcpy</span>(str, <span class="string">"hello"</span>);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; endl;</div><div class="line">    </div><div class="line">    <span class="built_in">free</span>(str);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　由于“指向指针的指针”这个概念不容易理解，我们可以用函数返回值来传递动态内存。这种方法更加简单，见示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *GetMemory3(<span class="keyword">int</span> num){</div><div class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * num);</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Test3(<span class="keyword">void</span>){</div><div class="line">    <span class="keyword">char</span> *str = NULL;</div><div class="line">    str = GetMemory3(<span class="number">100</span>);</div><div class="line">    </div><div class="line">    <span class="built_in">strcpy</span>(str, <span class="string">"hello"</span>);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; endl;</div><div class="line">    <span class="built_in">free</span>(str);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　用函数返回值来传递动态内存这种方法虽然好用，但是常常有人把<code>return</code>语句用错了。这里强调不要用<code>return</code>语句返回指向“栈内存”的指针，因为该内存在函数结束时自动消亡，见示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *GetString(<span class="keyword">void</span>){</div><div class="line">    <span class="keyword">char</span> p[] = <span class="string">"hello world"</span>;</div><div class="line">    <span class="keyword">return</span> p; <span class="comment">// 编译器将提出警告</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Test4(<span class="keyword">void</span>){</div><div class="line">    <span class="keyword">char</span> *str = NULL;</div><div class="line">    str = GetString(); <span class="comment">// str 的内容是垃圾</span></div><div class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; endl;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　用调试器逐步跟踪<code>Test4</code>，发现执行<code>str = GetString</code>语句后<code>str</code>不再是<code>NULL</code>指针，但是<code>str</code>的内容不是<code>“hello world”</code>而是垃圾。<br>　　如果把上述示例改写成如下示例，会怎么样？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *GetString2(<span class="keyword">void</span>){</div><div class="line">    <span class="keyword">char</span> *p = <span class="string">"hello world"</span>;</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Test5(<span class="keyword">void</span>){</div><div class="line">    <span class="keyword">char</span> *str = NULL;</div><div class="line">    str = GetString2();</div><div class="line">    <span class="built_in">cout</span>&lt;&lt; str &lt;&lt; endl;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　函数<code>Test5</code>运行虽然不会出错，但是函数<code>GetString2</code>的设计概念却是错误的。因为<code>GetString2</code>内的<code>“hello world”</code>是常量字符串，位于静态存储区，它在程序生命期内恒定不变。无论什么时候调用<code>GetString2</code>，它返回的始终是同一个“只读”的内存块。</p>
<h2 id="杜绝“野指针”">杜绝“野指针”</h2>
<p>　　“野指针”不是<code>NULL</code>指针，是指向“垃圾”内存的指针。人们一般不会错用<code>NULL</code>指针，因为用<code>if</code>语句很容易判断。但是“野指针”是很危险的，<code>if</code>语句对它不起作用。 “野指针”的成因主要有三种：</p>
<p>　　(1). 指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *p = NULL;</div><div class="line"><span class="keyword">char</span> *str = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="number">100</span>);</div></pre></td></tr></table></figure>

<p>　　(2). 指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。</p>
<p>　　(3). 指针操作超越了变量的作用域范围。这种情况让人防不胜防，示例程序如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A{</div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    <span class="keyword">void</span> Func(<span class="keyword">void</span>){ <span class="built_in">cout</span> &lt;&lt; “Func of <span class="keyword">class</span> A” &lt;&lt; endl; }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">void</span> Test(<span class="keyword">void</span>){</div><div class="line">    A *p;</div><div class="line">    {</div><div class="line">    A a;</div><div class="line">    p = &a; <span class="comment">// 注意 a 的生命期</span></div><div class="line">    }</div><div class="line">    p-&gt;Func(); <span class="comment">// p是“野指针”</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　函数<code>Test</code>在执行语句<code>p-&gt;Func()</code>时，对象a已经消失，而p是指向a的，所以p就成了“野指针”。但奇怪的是我运行这个程序时居然没有出错，这可能与编译器有关。</p>
<h2 id="有了malloc/free为什么还要new/delete">有了malloc/free为什么还要new/delete</h2>
<p>　　<code>malloc</code>与<code>free</code>是C++/C语言的标准库函数，<code>new/delete</code>是C++的运算符。它们都可用于申请动态内存和释放内存。<br>　　对于非内部数据类型的对象而言，光用<code>maloc/free</code>无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于<code>malloc/free</code>是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于<code>malloc/free</code>。<br>　　因此C++语言需要一个能完成动态内存分配和初始化工作的运算符<code>new</code>，以及一个能完成清理与释放内存工作的运算符<code>delet</code>e。注意<code>new/delete</code>不是库函数。我们先看一看<code>malloc/free</code>和<code>new/delete</code>如何实现对象的动态内存管理，见示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Obj{</div><div class="line">    <span class="keyword">public</span> :</div><div class="line">　　Obj(<span class="keyword">void</span>){ <span class="built_in">cout</span> &lt;&lt; “Initialization” &lt;&lt; endl; }</div><div class="line">　　~Obj(<span class="keyword">void</span>){ <span class="built_in">cout</span> &lt;&lt; “Destroy” &lt;&lt; endl; }</div><div class="line">　　<span class="keyword">void</span> Initialize(<span class="keyword">void</span>){ <span class="built_in">cout</span> &lt;&lt; “Initialization” &lt;&lt; endl; }</div><div class="line">　　<span class="keyword">void</span> Destroy(<span class="keyword">void</span>){ <span class="built_in">cout</span> &lt;&lt; “Destroy” &lt;&lt; endl; }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">void</span> UseMallocFree(<span class="keyword">void</span>){</div><div class="line">    Obj *a = (obj *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(obj)); <span class="comment">// 申请动态内存</span></div><div class="line">    a-&gt;Initialize(); <span class="comment">// 初始化</span></div><div class="line">    <span class="comment">//…</span></div><div class="line">    </div><div class="line">    a-&gt;Destroy(); <span class="comment">// 清除工作</span></div><div class="line">    <span class="built_in">free</span>(a); <span class="comment">// 释放内存</span></div><div class="line">}</div><div class="line"><span class="keyword">void</span> UseNewDelete(<span class="keyword">void</span>){</div><div class="line">    Obj *a = <span class="keyword">new</span> Obj; <span class="comment">// 申请动态内存并且初始化</span></div><div class="line">    <span class="comment">//…</span></div><div class="line"></div><div class="line">    <span class="keyword">delete</span> a; <span class="comment">// 清除并且释放内存</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　类<code>Obj</code>的函数<code>Initialize</code>模拟了构造函数的功能，函数<code>Destroy</code>模拟了析构函数的功能。函数<code>UseMallocFree</code>中，由于<code>malloc/free</code>不能执行构造函数与析构函数，必须调用成员函数<code>Initialize</code>和<code>Destroy</code>来完成初始化与清除工作。函数<code>UseNewDelete</code>则简单得多。<br>　　所以我们不要企图用<code>malloc/free</code>来完成动态对象的内存管理，应该用<code>new/delete</code>。由于内部数据类型的“对象”没有构造与析构的过程，对它们而言<code>malloc/free</code>和<code>new/delete</code>是等价的。<br>　　既然<code>new/delete</code>的功能完全覆盖了<code>malloc/free</code>，为什么C++不把<code>malloc/free</code>淘汰出局呢？这是因为C++程序经常要调用C函数，而C程序只能用<code>malloc/free</code>管理动态内存。<br>　　如果用<code>free</code>释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用<code>delete</code>释放“malloc申请的动态内存”，结果也会导致程序出错，但是该程序的可读性很差。所以<code>new/delete</code>必须配对使用，<code>malloc/free</code>也一样。</p>
<h2 id="内存耗尽怎么办">内存耗尽怎么办</h2>
<p>　　如果在申请动态内存时找不到足够大的内存块，<code>malloc</code>和<code>new</code>将返回<code>NULL</code>指针，宣告内存申请失败。通常有三种方式处理“内存耗尽”问题。<br>　　(1). 判断指针是否为<code>NULL</code>，如果是则马上用<code>return</code>语句终止本函数。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Func(<span class="keyword">void</span>){</div><div class="line">    A *a = <span class="keyword">new</span> A;</div><div class="line">    <span class="keyword">if</span>(a == NULL)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    …</div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　(2). 判断指针是否为<code>NULL</code>，如果是则马上用<code>exit(1)</code>终止整个程序的运行。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">void</span> Func(<span class="keyword">void</span>){</div><div class="line">    A *a = <span class="keyword">new</span> A;</div><div class="line">    <span class="keyword">if</span>(a == NULL){</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; “Memory Exhausted” &lt;&lt; endl;</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    }</div><div class="line">    …</div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　(3). 为<code>new</code>和<code>malloc</code>设置异常处理函数。例如Visual C++可以用<code>_set_new_hander</code>函数为<code>new</code>设置用户自己定义的异常处理函数，也可以让<code>malloc</code>享用与<code>new</code>相同的异常处理函数。详细内容请参考C++使用手册。<br>　　上述 (1)、(2) 方式使用最普遍。如果一个函数内有多处需要申请动态内存，那么方式 (1) 就显得力不从心（释放内存很麻烦），应该用方式 (2) 来处理。<br>　　很多人不忍心用<code>exit(1)</code>，问：“不编写出错处理程序，让操作系统自己解决行不行？”<br>　　不行。如果发生“内存耗尽”这样的事情，一般说来应用程序已经无药可救。如果不用<code>exit(1)</code> 把坏程序杀死，它可能会害死操作系统。道理如同：如果不把歹徒击毙，歹徒在老死之前会犯下更多的罪。<br>　　有一个很重要的现象要告诉大家。对于32位以上的应用程序而言，无论怎样使用<code>malloc与new</code>，几乎不可能导致“内存耗尽”。对于32位以上的应用程序，“内存耗尽”错误处理程序毫无用处。这下可把Unix和Windows程序员们乐坏了：反正错误处理程序不起作用，我就不写了，省了很多麻烦。<br>　　必须强调：不加错误处理将导致程序的质量很差，千万不可因小失大。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> main(<span class="keyword">void</span>){</div><div class="line">    <span class="keyword">float</span> *p = NULL;</div><div class="line">    <span class="keyword">while</span>(TRUE){</div><div class="line">        p = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">1000000</span>];</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; “eat memory” &lt;&lt; endl;</div><div class="line">        <span class="keyword">if</span>(p==NULL)</div><div class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h2 id="malloc/free的使用要点">malloc/free的使用要点</h2>
<p>　　函数<code>malloc</code>的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> * <span class="built_in">malloc</span>(size_t size);</div></pre></td></tr></table></figure>

<p>　　用<code>malloc</code>申请一块长度为<code>length</code>的整数类型的内存，程序如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * length);</div></pre></td></tr></table></figure>

<p>　　我们应当把注意力集中在两个要素上：“类型转换”和“sizeof”。<br>　　<code>* malloc</code>返回值的类型是<code>void*</code>，所以在调用<code>malloc</code>时要显式地进行类型转换，将<code>void *</code>转换成所需要的指针类型。<br>　　<code>* malloc</code>函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。我们通常记不住<code>int</code>, <code>float</code>等数据类型的变量的确切字节数。例如<code>int</code>变量在16位系统下是2个字节，在32位下是4个字节；而<code>float</code>变量在16位系统下是4个字节，在32位下也是4个字节。最好用以下程序作一次测试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; endl;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; endl;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) &lt;&lt; endl;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span>) &lt;&lt; endl;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>) &lt;&lt; endl;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span>) &lt;&lt; endl;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span>) &lt;&lt; endl;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">void</span> *) &lt;&lt; endl;</div></pre></td></tr></table></figure>

<p>　　在<code>malloc</code>的“()”中使用<code>sizeof</code>运算符是良好的风格，但要当心有时我们会昏了头，写出 <code>p = malloc(sizeof(p))</code>这样的程序来。<br>　　函数<code>free</code>的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> <span class="built_in">free</span>( <span class="keyword">void</span> * memblock );</div></pre></td></tr></table></figure>

<p>　　为什么<code>free</code>函数不象<code>mallo</code>c函数那样复杂呢？这是因为指针<code>p</code>的类型以及它所指的内存的容量事先都是知道的，语句<code>free(p)</code>能正确地释放内存。如果<code>p</code>是<code>NULL</code>指针，那么<code>free</code>对<code>p</code>无论操作多少次都不会出问题。如果<code>p</code>不是<code>NULL</code>指针，那么<code>free</code>对<code>p</code>连续操作两次就会导致程序运行错误。</p>
<h2 id="new/delete的使用要点">new/delete的使用要点</h2>
<p>　　运算符<code>new</code>使用起来要比函数<code>malloc</code>简单得多，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *p1 = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * length);</div><div class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> <span class="keyword">int</span>[length];</div></pre></td></tr></table></figure>

<p>　　这是因为<code>new</code>内置了<code>sizeof</code>、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，<code>new</code>在创建动态对象的同时完成了初始化工作。如果对象有多个构造函数，那么<code>new</code>的语句也可以有多种形式。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Obj{</div><div class="line">    <span class="keyword">public</span> :</div><div class="line">    Obj(<span class="keyword">void</span>); <span class="comment">// 无参数的构造函数</span></div><div class="line">    Obj(<span class="keyword">int</span> x); <span class="comment">// 带一个参数的构造函数</span></div><div class="line">    …</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">void</span> Test(<span class="keyword">void</span>){</div><div class="line">    Obj *a = <span class="keyword">new</span> Obj;</div><div class="line">    Obj *b = <span class="keyword">new</span> Obj(<span class="number">1</span>); <span class="comment">// 初值为1</span></div><div class="line">    …</div><div class="line">    <span class="keyword">delete</span> a;</div><div class="line">    <span class="keyword">delete</span> b;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>　　如果用<code>new</code>创建对象数组，那么只能使用对象的无参数构造函数。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Obj *objects = <span class="keyword">new</span> Obj[<span class="number">100</span>]; <span class="comment">// 创建100个动态对象</span></div></pre></td></tr></table></figure>

<p>　　不能写成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Obj *objects = <span class="keyword">new</span> Obj[<span class="number">100</span>](<span class="number">1</span>);<span class="comment">// 创建100个动态对象的同时赋初值1</span></div></pre></td></tr></table></figure>

<p>　　在用<code>delete</code>释放对象数组时，留意不要丢了符号‘[]’。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">delete</span> []objects; <span class="comment">// 正确的用法</span></div><div class="line"><span class="keyword">delete</span> objects; <span class="comment">// 错误的用法</span></div></pre></td></tr></table></figure>

<p>　　后者有可能引起程序崩溃和内存泄漏。</p>
<h2 id="Conclusion">Conclusion</h2>
<ul>
<li>越是怕指针，就越要使用指针。不会正确使用指针，肯定算不上是合格的程序员。</li>
<li>必须养成使用“调试器逐步跟踪程序”的习惯，只有这样才能发现问题的本质。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　内存管理是C++最令人切齿痛恨的问题，也是C++最有争议的问题，C++高手从中获得了更好的性能，更大的自由，C++菜鸟的收获则是一遍一遍的检查代码和对C++的痛恨，但内存管理在C++中无处不在，内存泄漏几乎在每个C++程序中都会发生，因此要想成为C++高手，内存管理一关]]>
    </summary>
    
      <category term="C/C++" scheme="http://chenqx.github.com/tags/C-C/"/>
    
      <category term="C/C++" scheme="http://chenqx.github.com/categories/C-C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简明 Vim 练级攻略]]></title>
    <link href="http://chenqx.github.com/2014/09/20/Learn-Vim-Progressively/"/>
    <id>http://chenqx.github.com/2014/09/20/Learn-Vim-Progressively/</id>
    <published>2014-09-20T10:11:03.000Z</published>
    <updated>2014-11-13T13:57:35.000Z</updated>
    <content type="html"><![CDATA[<p>　　vim的学习曲线相当的大<a href="http://coolshell.cn/articles/3125.html" target="_blank" rel="external">（参看各种文本编辑器的学习曲线）</a>，所以，如果你一开始看到的是一大堆VIM的命令分类，你一定会对这个编辑器失去兴趣的。下面的文章翻译自<a href="http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/" target="_blank" rel="external">《Learn Vim Progressively》</a>，我觉得这是给新手最好的VIM的升级教程了，没有列举所有的命令，只是列举了那些最有用的命令，非常不错。以下是正文。</p>
<p>　　你想以最快的速度学习人类史上最好的文本编辑器VIM吗？你先得懂得如何在VIM幸存下来，然后一点一点地学习各种戏法。</p>
<p>　　Vim the Six Billion Dollar editor</p>
<blockquote>
<p><em>Better, Stronger, Faster.</em></p>
</blockquote>
<p>　　学习 vim 并且其会成为你最后一个使用的文本编辑器。没有比这个更好的文本编辑器了，非常地难学，但是却不可思议地好用。<br>　　我建议下面这四个步骤：<br>　　<br>　　(1). 存活<br>　　(2). 感觉良好<br>　　(3). 觉得更好，更强，更快<br>　　(4). 使用VIM的超能力</p>
<p>　　当你走完这篇文章，你会成为一个vim的 superstar。在开始学习以前，我需要给你一些警告：</p>
<ul>
<li>学习vim在开始时是痛苦的。</li>
<li>需要时间</li>
<li>需要不断地练习，就像你学习一个乐器一样。</li>
<li>不要期望你能在3天内把vim练得比别的编辑器更有效率。</li>
<li>事实上，你需要2周时间的苦练，而不是3天。</li>
</ul>
<h2 id="1st_Level_–_Survive"><strong>1st Level – Survive</strong></h2>
<p>　　1. 安装 <a href="http://www.vim.org/docs.php" target="_blank" rel="external">Vim</a><br>　　2. 启动 Vim<br>　　3. <strong>什么也别干！请先阅读</strong></p>
<p>　　当你安装好一个编辑器后，你一定会想在其中输入点什么东西，然后看看这个编辑器是什么样子。但vim不是这样的，请按照下面的命令操作：</p>
<pre><code><span class="blockquote">&gt;　启 动Vim后，vim在 Normal 模式下。</span>
<span class="blockquote">&gt;　让我们进入 Insert 模式，请按下键 i。(你会看到vim左下角有一个–insert–字样，表示，你可以以插入的方式输入了）</span>
<span class="blockquote">&gt;　此时，你可以输入文本了，就像你用“记事本”一样。</span>
<span class="blockquote">&gt;　如果你想返回 Normal 模式，请按 ESC 键</span>
</code></pre><p>　　现在，你知道如何在 <code>Insert</code> 和 <code>Normal</code> 模式下切换了。下面是一些命令，可以让你在 Normal 模式下幸存下来：</p>
<pre><code><span class="blockquote">&gt;　i → Insert 模式，按 ESC 回到 Normal 模式.</span>
<span class="blockquote">&gt;　x → 删当前光标所在的一个字符。</span>
<span class="blockquote">&gt;　:wq → 存盘 + 退出 (:w 存盘, :q 退出)   （陈皓注：:w 后可以跟文件名）</span>
<span class="blockquote">&gt;　dd → 删除当前行，并把删除的行存到剪贴板里</span>
<span class="blockquote">&gt;　p → 粘贴剪贴板</span>
</code></pre><p><strong>推荐:</strong></p>
<pre><code>&gt;　hjkl (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注<span class="symbol">:</span> j 就像下箭头。
<span class="input"><span class="prompt">&gt;　:help &lt;command&gt;</span> → 显示相关命令的帮助。你也可以就输入 <span class="symbol">:help</span> 而不跟命令。（陈皓注：退出帮助需要输入<span class="symbol">:q</span>）</span>
</code></pre><p>　　你能在vim幸存下来只需要上述的那5个命令，你就可以编辑文本了，你一定要把这些命令练成一种下意识的状态。于是你就可以开始进阶到第二级了。</p>
<p>　　但是，在你进入第二级时，需要再说一下 Normal 模式。在一般的编辑器下，当你需要copy一段文字的时候，你需要使用 Ctrl 键，比如：<code>Ctrl-C</code>。也就是说，Ctrl键就好像功能键一样，当你按下了功能键Ctrl后，C就不在是C了，而且就是一个命令或是一个快键键了，在VIM的Normal模式下，所有的键就是功能键了。这个你需要知道。<br>　　<br><strong>标记:</strong></p>
<pre><code>&gt;　下面的文字中，如果是 <span class="variable">Ctrl</span>-λ我会写成 ＜<span class="variable">C</span>-λ＞.
&gt;　以 : 开始的命令你需要输入 &lt;enter&gt;回车，例如 — 如果我写成 :q 也就是说你要输入 :q＜enter＞.
</code></pre><h2 id="2nd_Level_–_Feel_comfortable"><strong>2nd Level – Feel comfortable</strong></h2>
<p>　　上面的那些命令只能让你存活下来，现在是时候学习一些更多的命令了，下面是我的建议：所有的命令都需要在Normal模式下使用，如果你不知道现在在什么样的模式，你就狂按几次ESC键。</p>
<h3 id="各种插入模式">各种插入模式</h3>
<pre><code><span class="blockquote">&gt;　a → 在光标后插入</span>
<span class="blockquote">&gt;　o → 在当前行后插入一个新行</span>
<span class="blockquote">&gt;　O → 在当前行前插入一个新行</span>
<span class="blockquote">&gt;　cw → 替换从光标所在位置后到一个单词结尾的字符</span>
</code></pre><h3 id="简单的移动光标">简单的移动光标</h3>
<pre><code><span class="blockquote">&gt;　0 → 数字零，到行头</span>
<span class="blockquote">&gt;　^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等）</span>
<span class="blockquote">&gt;　$ → 到本行行尾</span>
<span class="blockquote">&gt;　g_ → 到本行最后一个不是blank字符的位置。</span>
<span class="blockquote">&gt;　/pattern → 搜索 pattern 的字符串（如果搜索出多个匹配，可按n键到下一个）</span>
</code></pre><h3 id="拷贝/粘贴">拷贝/粘贴</h3>
<pre><code><span class="blockquote">&gt;　P → 粘贴（陈皓注：p/P都可以，p是表示在当前位置之后，P表示在当前位置之前）</span>
<span class="blockquote">&gt;　yy → 拷贝当前行当行于 ddP</span>
</code></pre><h3 id="简单的移动光标-1">简单的移动光标</h3>
<pre><code>&gt;　u → undo
<span class="input"><span class="prompt">&gt;　&lt;C-r&gt;</span> → redo</span>
</code></pre><h3 id="打开/保存/退出/改变文件">打开/保存/退出/改变文件</h3>
<pre><code><span class="input"><span class="prompt">&gt;　:e &lt;path/to/file&gt;</span> → 打开一个文件</span>
&gt;　<span class="symbol">:w</span> → 存盘
<span class="input"><span class="prompt">&gt;　:saveas &lt;path/to/file&gt;</span> → 另存为 &lt;path/to/file&gt;
&gt;　<span class="symbol">:x</span>， <span class="constant">ZZ</span> 或 <span class="symbol">:wq</span> → 保存并退出 (<span class="symbol">:x</span> 表示仅在需要时保存，<span class="constant">ZZ</span>不需要输入冒号并回车)</span>
&gt;　<span class="symbol">:q!</span> → 退出不保存 <span class="symbol">:qa!</span> 强行退出所有的正在编辑的文件，就算别的文件有更改。
&gt;　<span class="symbol">:bn</span> 和 <span class="symbol">:bp</span> → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（我喜欢使用<span class="symbol">:n</span>到下一个文件）
</code></pre><p>　　花点时间熟悉一下上面的命令，一旦你掌握他们了，你就几乎可以干其它编辑器都能干的事了。但是到现在为止，你还是觉得使用vim还是有点笨拙，不过没关系，你可以进阶到第三级了。</p>
<h2 id="3rd_Level_–_Better_Stronger_Faster"><strong>3rd Level – Better Stronger Faster</strong></h2>
<p>　　先恭喜你！你干的很不错。我们可以开始一些更为有趣的事了。在第三级，我们只谈那些和vi可以兼容的命令。</p>
<h3 id="更好">更好</h3>
<p>　　下面，让我们看一下vim是怎么重复自己的：</p>
<pre><code>&gt;　. → (小数点) 可以重复上一次的命令
<span class="input"><span class="prompt">&gt;　N&lt;command&gt;</span> → 重复某个命令<span class="constant">N</span>次</span>
</code></pre><p>　　下面是一个示例，找开一个文件你可以试试下面的命令：</p>
<pre><code><span class="blockquote">&gt;　2dd → 删除2行</span>
<span class="blockquote">&gt;　3p → 粘贴文本3次</span>
100idesu [ESC] → 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “
<span class="blockquote">&gt;　. → 重复上一个命令—— 100 “desu “.</span>
<span class="blockquote">&gt;　3. → 重复 3 次 “desu” (注意：不是 300，你看，VIM多聪明啊).</span>
</code></pre><h3 id="更强">更强</h3>
<p>　　你要让你的光标移动更有效率，你一定要了解下面的这些命令，千万别跳过。</p>
<pre><code><span class="blockquote">&gt;　1. NG → 到第 N 行 （注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行）</span>
<span class="blockquote">&gt;　2.  gg → 到第一行。（相当于1G，或 :1）</span>
<span class="blockquote">&gt;　3.  G → 到最后一行。</span>
<span class="blockquote">&gt;　4.  按单词移动：</span>
 　　　w → 到下一个单词的开头。
 　　　e → 到下一个单词的结尾。
 　　　如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成（程序变量）
  　　 如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。（程序语句）
</code></pre><p>　　<img src="http://newtonblogimg.qiniudn.com/word_moves.jpg" alt="Word Moves"></p>
<p>　　下面，让我来说说最强的光标移动：</p>
<pre><code><span class="blockquote">&gt;　 % : 匹配括号移动，包括 (, {, [. （你需要把光标先移到括号上）</span>
<span class="blockquote">&gt;　 * 和 #:  匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）</span>
</code></pre><p>　　相信我，上面这三个命令对程序员来说是相当强大的。</p>
<h3 id="更快">更快</h3>
<p>　　你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干：<code>＜start position＞＜command＞＜end position＞</code></p>
<p>　　例如 0y$ 命令意味着：</p>
<pre><code><span class="blockquote">&gt;　 0 → 先到行头</span>
<span class="blockquote">&gt;　 y → 从这里开始拷贝</span>
<span class="blockquote">&gt;　 $ → 拷贝到本行最后一个字符</span>
<span class="blockquote">&gt;　 你可可以输入 ye，从当前位置拷贝到本单词的最后一个字符。</span>
</code></pre><p>　　你也可以输入 y2/foo 来拷贝2个 “foo” 之间的字符串。</p>
<p>　　还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝：</p>
<pre><code><span class="blockquote">&gt;　 d (删除 )</span>
<span class="blockquote">&gt;　 v (可视化的选择)</span>
<span class="blockquote">&gt;　 gU (变大写)</span>
<span class="blockquote">&gt;　 gu (变小写)</span>
<span class="blockquote">&gt;　 等等</span>
</code></pre><p>（可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等）</p>
<h2 id="4th_Level_–_Vim_Superpowers"><strong>4th Level – Vim Superpowers</strong></h2>
<p>　　你只需要掌握前面的命令，你就可以很舒服的使用VIM了。但是，现在，我们向你介绍的是VIM杀手级的功能。下面这些功能是我只用vim的原因。</p>
<h3 id="在当前行上移动光标">在当前行上移动光标</h3>
<pre><code><span class="blockquote">&gt;　0 → 到行头</span>
<span class="blockquote">&gt;　^ → 到本行的第一个非blank字符</span>
<span class="blockquote">&gt;　$ → 到行尾</span>
<span class="blockquote">&gt;　g_ → 到本行最后一个不是blank字符的位置。</span>
<span class="blockquote">&gt;　fa → 到下一个为a的字符处，你也可以fs到下一个为s的字符。</span>
<span class="blockquote">&gt;　t, → 到逗号前的第一个字符。逗号可以变成其它字符。</span>
<span class="blockquote">&gt;　3fa → 在当前行查找第三个出现的a。</span>
<span class="blockquote">&gt;　F 和 T → 和 f 和 t 一样，只不过是相反方向。</span>
</code></pre><p><img src="http://newtonblogimg.qiniudn.com/line_moves.jpg" alt="Line Moves"></p>
<p>　　还有一个很有用的命令是 dt” → 删除所有的内容，直到遇到双引号—— “。</p>
<h3 id="区域选择">区域选择</h3>
<p>　　在visual 模式下，这些命令很强大，其命令格式为<code>&lt;action&gt;a&lt;object&gt;</code>和 <code>&lt;action&gt;i&lt;object&gt;</code></p>
<pre><code><span class="blockquote">&gt;　action可以是任何的命令，如 d (删除), y (拷贝), v (可以视模式选择)。</span>
<span class="blockquote">&gt;　object 可能是： w 一个单词， W 一个以空格为分隔的单词， s 一个句字， p 一个段落。也可以是一个特别的字符："、 '、 )、 }、 ]。</span>
</code></pre><p>　　假设你有一个字符串 (map (+) (“foo”)).而光标键在第一个 o 的位置。</p>
<pre><code>&gt;　<span class="keyword">vi</span><span class="string">" → 会选择 foo.
</span>&gt;　va<span class="string">" → 会选择 "</span>foo<span class="string">".
</span>&gt;　<span class="keyword">vi</span>) → 会选择 <span class="string">"foo"</span>.
&gt;　va) → 会选择(<span class="string">"foo"</span>).
&gt;　v2i) → 会选择 <span class="built_in">map</span> (+) (<span class="string">"foo"</span>)
&gt;　v2a) → 会选择 (<span class="built_in">map</span> (+) (<span class="string">"foo"</span>))
</code></pre><p><img src="http://newtonblogimg.qiniudn.com/textobjects.png" alt="Text Objects"></p>
<h3 id="块操作">块操作</h3>
<p>　　块操作，典型的操作： <code>0 &lt; C-v&gt; &lt; C-d&gt; I-- [ESC]</code></p>
<pre><code>&gt;　^ → 到行头
<span class="input"><span class="prompt">&gt;　&lt;　C-v&gt;</span> → 开始块操作</span>
<span class="input"><span class="prompt">&gt;　&lt;　C-d&gt;</span> → 向下移动 &gt; (你也可以使用hjkl来移动光标，或是使用%，或是别的)</span>
&gt;　<span class="constant">I</span>-- [<span class="constant">ESC</span>] → <span class="constant">I</span>是插入，插入“--”，按<span class="constant">ESC</span>键来为每一行生效。
</code></pre><p><img src="http://newtonblogimg.qiniudn.com/rectangular-blocks.gif" alt="Rectangular Blocks"></p>
<p>　　在Windows下的vim，你需要使用 <code>&lt;C-q&gt;</code>而不是 <code>&lt;C-v&gt;</code> ，<code>&lt;C-v&gt;</code> 是拷贝剪贴板。</p>
<h3 id="自动提示">自动提示</h3>
<p>　　在 Insert 模式下，你可以输入一个词的开头，然后按 <code>&lt;C-p&gt;</code>或是<code>&lt; C-n&gt;</code>，自动补齐功能就出现了……<br> 　<img src="http://newtonblogimg.qiniudn.com/completion.gif" alt="Completion"></p>
<h3 id="宏录制">宏录制</h3>
<pre><code><span class="blockquote">&gt;　qa 把你的操作记录在寄存器 a。</span>
<span class="blockquote">&gt;　于是 @a 会replay被录制的宏。</span>
<span class="blockquote">&gt;　@@ 是一个快捷键用来replay最新录制的宏。</span>
</code></pre><hr>
<pre><code>&gt;　示例
在一个只有一行且这一行只有“<span class="number">1</span>”的文本中，键入如下命令：
&gt;　 qaYp&lt; <span class="constant">C</span>-a&gt;q→
<span class="input"><span class="prompt">　　　:qa 开始录制
　　　:Yp 复制行.
　　　:&lt; C-a&gt;</span> 增加<span class="number">1</span>.</span>
　　　<span class="symbol">:q</span> 停止录制.
&gt;　 <span class="variable">@a</span> → 在<span class="number">1</span>下面写下 <span class="number">2</span>
&gt;　 @@ → 在<span class="number">2</span> 正面写下<span class="number">3</span>
&gt;　 现在做 <span class="number">100</span>@@ 会创建新的<span class="number">100</span>行，并把数据增加到 <span class="number">103</span>.
</code></pre><p><img src="http://newtonblogimg.qiniudn.com/macros.gif" alt="Macros"></p>
<h3 id="可视化选择">可视化选择</h3>
<p>　　前面，我们看到了 <c-v>的示例 （在Windows下应该是<code>&lt;C-q&gt;</code>），我们可以使用 v 和 V。一但被选好了，你可以做下面的事：</c-v></p>
<pre><code>&gt;　 <span class="constant">J</span> → 把所有的行连接起来（变成一行）
<span class="input"><span class="prompt">&gt;　 &lt; 或 &gt;</span> → 左右缩进</span>
&gt;　 = → 自动给缩进 （陈皓注：这个功能相当强大，我太喜欢了）
</code></pre><p><img src="http://newtonblogimg.qiniudn.com/autoindent.gif" alt="Auto Indent"></p>
<p>　　在所有被选择的行后加上点东西：</p>
<pre><code>&gt;　 &lt;<span class="constant">C</span>-v&gt;
<span class="input"><span class="prompt">&gt;　 选中相关的行 (可使用 j 或 &lt;C-d&gt;</span> 或是 /pattern 或是 % 等……)</span>
&gt;　 <span class="variable">$ </span>到行最后
&gt;　 <span class="constant">A</span>, 输入字符串，按 <span class="constant">ESC</span>。
</code></pre><p><img src="http://newtonblogimg.qiniudn.com/append-to-many-lines.gif" alt="Append to Many Lines"></p>
<h3 id="分屏">分屏</h3>
<p>　　下面是主要的命令，你可以使用VIM的帮助 :<code>help split</code>。你可以参考本站以前的一篇文章VIM分屏。</p>
<pre><code>&gt;　 :split → 创建分屏 (:vsplit创建垂直分屏)
&gt;　 <span class="tag">&lt;<span class="title">C-w</span>&gt;</span><span class="tag">&lt;<span class="title">dir</span>&gt;</span> : dir就是方向，可以是 hjkl 或是 ←↓↑→ 中的一个，其用来切换分屏。
&gt;　 <span class="tag">&lt;<span class="title">C-w</span>&gt;</span>_ (或 <span class="tag">&lt;<span class="title">C-w</span>&gt;</span>|) : 最大化尺寸 (<span class="tag">&lt;<span class="title">C-w</span>&gt;</span>| 垂直分屏)
&gt;　 <span class="tag">&lt;<span class="title">C-w</span>&gt;</span>+ (或 <span class="tag">&lt;<span class="title">C-w</span>&gt;</span>-) : 增加尺寸
</code></pre><p><img src="http://newtonblogimg.qiniudn.com/split.gif" alt="Split"></p>
<h2 id="Conclusion"><strong>Conclusion</strong></h2>
<p>　　上面是作者最常用的90%的命令。　<br>　　我建议你每天都学1到2个新的命令。<br>　　在两到三周后，你会感到vim的强大的。<br>　　有时候，学习VIM就像是在死背一些东西。<br>　　幸运的是，vim有很多很不错的工具和优秀的文档。<br>　　运行vimtutor直到你熟悉了那些基本命令。<br>　　其在线帮助文档中你应该要仔细阅读的是 :help usr_02.txt.<br>　　你会学习到诸如  !， 目录，寄存器，插件等很多其它的功能。<br>　　学习vim就像学弹钢琴一样，一旦学会，受益无穷。</p>
<h2 id="Further_reading"><strong>Further reading</strong></h2>
<p>　　from <a href="http://coolshell.cn/articles/5426.html" target="_blank" rel="external">@coolshell</a>     </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　vim的学习曲线相当的大<a href="http://coolshell.cn/articles/3125.html" target="_blank" rel="external">（参看各种文本编辑器的学习曲线）</a>，所以，如果你一开始看到的是一大堆VIM的命令]]>
    </summary>
    
      <category term="Linux" scheme="http://chenqx.github.com/tags/Linux/"/>
    
      <category term="Vim" scheme="http://chenqx.github.com/tags/Vim/"/>
    
      <category term="TextEditor" scheme="http://chenqx.github.com/tags/TextEditor/"/>
    
      <category term="Linux" scheme="http://chenqx.github.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cmd - An Effective Markdown Editor]]></title>
    <link href="http://chenqx.github.com/2014/09/10/Cmd-An-Effective-Markdown-Editor/"/>
    <id>http://chenqx.github.com/2014/09/10/Cmd-An-Effective-Markdown-Editor/</id>
    <published>2014-09-10T08:36:24.000Z</published>
    <updated>2014-11-11T02:17:45.000Z</updated>
    <content type="html"><![CDATA[<p>　　为了更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 为我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。</p>
<p>　　您可以使用 Cmd Markdown：</p>
<blockquote>
<ul>
<li>整理知识，学习笔记</li>
<li>发布日记，杂文，所见所想</li>
<li>撰写发布技术文稿（代码支持）</li>
<li>撰写发布学术论文（LaTeX 公式支持）</li>
</ul>
</blockquote>
<h2 id="什么是_Markdown">什么是 Markdown</h2>
<p>　　Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p>
<h3 id="书写一个质能守恒公式[^LaTeX]">书写一个质能守恒公式[^LaTeX]</h3>
<p>　　$$E=mc^2$$</p>
<h3 id="高亮一段代码[^code]">高亮一段代码[^code]</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="decorator">@requires_authorization</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="comment"># A comment</span></div><div class="line">    <span class="keyword">print</span> <span class="string">'hello world'</span></div></pre></td></tr></table></figure>

<h3 id="高效绘制_流程图">高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图" target="_blank" rel="external">流程图</a></h3>
<figure class="highlight flow"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">st=&gt;<span class="symbol">start:</span> <span class="constant">Start</span></div><div class="line">op=&gt;<span class="symbol">operation:</span> <span class="constant">Your Operation</span></div><div class="line"><span class="keyword">cond</span>=&gt;<span class="symbol">condition:</span> <span class="constant">Yes </span><span class="keyword">or</span> <span class="constant">No?</span></div><div class="line">e=&gt;<span class="keyword">end</span></div><div class="line"></div><div class="line">st-&gt;op-&gt;<span class="keyword">cond</span></div><div class="line"><span class="keyword">cond</span>(yes)-&gt;e</div><div class="line"><span class="keyword">cond</span>(no)-&gt;op</div></pre></td></tr></table></figure>

<h3 id="高效绘制_序列图">高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图" target="_blank" rel="external">序列图</a></h3>
<figure class="highlight seq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="type">Alice</span>-&gt;<span class="type">Bob</span>: <span class="type">Hello</span> <span class="type">Bob</span>, how are you?</div><div class="line"><span class="type">Note</span> right <span class="keyword">of</span> <span class="type">Bob</span>: <span class="type">Bob</span> thinks</div><div class="line"><span class="type">Bob</span><span class="comment">--&gt;Alice: I am good thanks!</span></div></pre></td></tr></table></figure>

<h3 id="绘制表格">绘制表格</h3>
<table>
<thead>
<tr>
<th>项目</th>
<th style="text-align:right">价格</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>计算机</td>
<td style="text-align:right">$1600</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td>手机</td>
<td style="text-align:right">$12</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td>管线</td>
<td style="text-align:right">$1</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
<h3 id="更详细语法说明">更详细语法说明</h3>
<p>　　想要查看更详细的语法说明，可以参考我们准备的 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown" target="_blank" rel="external">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册" target="_blank" rel="external">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。</p>
<p>　　总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p>
<h2 id="什么是_Cmd_Markdown">什么是 Cmd Markdown</h2>
<p>　　您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑/发布/阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。</p>
<h3 id="实时同步预览">实时同步预览</h3>
<p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p>
<h3 id="编辑工具栏">编辑工具栏</h3>
<p>　　也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p>
<p><img src="https://www.zybuluo.com/static/img/toolbar-editor.png" alt="tool-editor"></p>
<h3 id="编辑模式">编辑模式</h3>
<p>　　完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右测的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p>
<h3 id="实时的云端文稿">实时的云端文稿</h3>
<p>　　为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p>
<h3 id="离线模式">离线模式</h3>
<p>　　在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p>
<h3 id="管理工具栏">管理工具栏</h3>
<p>　　为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p>
<p><img src="https://www.zybuluo.com/static/img/toolbar-manager.jpg" alt="tool-manager"></p>
<p>　　通过管理工具栏可以：</p>
<p><i class="icon-share"></i> 　　发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class="icon-file"></i> 　　新建：开始撰写一篇新的文稿<br><i class="icon-trash"></i> 　　删除：删除当前的文稿<br><i class="icon-cloud"></i> 　　导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class="icon-reorder"></i> 　　列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class="icon-pencil"></i> 　　模式：切换 普通/Vim/Emacs 编辑模式</p>
<h3 id="阅读工具栏">阅读工具栏</h3>
<p><img src="https://www.zybuluo.com/static/img/toolbar-reader.jpg" alt="tool-manager"></p>
<p>　　通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p>
<p>工具栏上的五个图标依次为：</p>
<p><i class="icon-list"></i> 　　目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class="icon-chevron-sign-left"></i> 　　视图：互换左边编辑区和右边预览区的位置<br><i class="icon-adjust"></i> 　　主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class="icon-desktop"></i> 　　阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class="icon-fullscreen"></i> 　　全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p>
<h3 id="阅读模式">阅读模式</h3>
<p>　　在 <strong>阅读工具栏</strong> 点击 <i class="icon-desktop"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p>
<h3 id="标签、分类和搜索">标签、分类和搜索</h3>
<p>　　在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p>
<p>　　标签： 未分类</p>
<p>　　标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p>
<p><img src="https://www.zybuluo.com/static/img/file-list.png" alt="file-list"></p>
<h3 id="文稿发布和分享">文稿发布和分享</h3>
<p>　　在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class="icon-share"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p>
<p>See more <a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="external">@Cmdeditor</a>     </p>
<p>[^LaTeX]: 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="external">MathJax</a> 参考更多使用方法。</p>
<p>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>　　为了更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 为我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。</p>
<p>　　您可以使用 Cmd Markdown：</p>]]>
    </summary>
    
      <category term="Markdown" scheme="http://chenqx.github.com/tags/Markdown/"/>
    
      <category term="TextEditor" scheme="http://chenqx.github.com/tags/TextEditor/"/>
    
      <category term="Tools" scheme="http://chenqx.github.com/categories/Tools/"/>
    
  </entry>
  
</feed>
